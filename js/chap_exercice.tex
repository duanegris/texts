%----------------------------------- Exemples -------------------------------
\chapter{Exercices corrigés}

Voici une série d'exercices permettant d'illustrer les notions évoquées
dans ce chapitre. L'énoncé est suivi d'un programme solution en JavaScript, 
puis de commentaires sur la solution.
Bien évidemment, il ne s'agit que d'une solution parmi différentes possibles.


\section{Fonction simple}

Utilisation de {\tt function()}, \instrcle{max()}.\\

Ecrire une fonction qui, étant donné trois nombres entiers non nul,
$a$, $b$ et $c$,
détermine si l'un des nombres est égal à la somme des deux autres.
La fonction renvoie ce nombre s'il existe, 0 sinon.

\begin{Verbatim}[frame=single,numbers=left]
function sommededeux (a,b,c) {

  var m = Math.max(a,Math.max(b,c));

  if (a+b+c== 2*m) 
       return(m);
  else 
       return(0);
}
\end{Verbatim}
La solution proposée repose sur la constatation suivante :
si $a = b + c$ alors 
\begin{itemize}
\item $a$ est supérieur à $b$ et à $c$
\item $a+b+c = 2a$
\end{itemize}
La difficulté est que nous ne savons pas qui de $a$, $b$ ou $c$ est le plus grand.
On doit donc le déterminer : il n'existe pas en Javascript de fonction donnant le \motcle{maximum} d'un ensemble d'éléments, mais on peut utiliser la fonction \texttt{max} du module \texttt{Math} qui rend le maximum entre deux nombres. \\

Notons que cette solution est plus élégante et plus facilement adaptable
que la solution qui consiste à tester les différentes possibilités.
On peut effectivement écrire :
\begin{Verbatim}[frame=single]
   if (a==b+c) return (a)
   else if (b==a+c) return (b)
        else if (c=a+b) return (c)
	       else return (0);
\end{Verbatim}
mais le nombre de tests augmenterait rapidement si le problème se complixifiait
un tant soit peu.
   



\section{Calcul d'une moyenne}

Utilisation de {\tt for, Array, prompt()} et \instrcle{parseInt()}.\\

Ecrire un programme qui calcule la moyenne d'un ensemble de notes.
Le programme doit ouvrir une fenêtre pour demander le nombre de notes,
puis ouvrir une nouvelle fenêtre pour entrer chacune des notes. 
Quand toutes les notes sont saisies, une fenêtre affiche la moyenne.
\begin{Verbatim}[frame=single,numbers=left]
       var note = new Array();
       var moyenne = 0;
       var nb;   
        
             nb = prompt("Entrer le nombre de notes");
             nb = parseInt(nb,10);
             for (var i=0;i<nb;i++){
                note[i] = prompt("Entrer la note " + (i+1));
                note[i] = parseInt(note[i],10);
                moyenne += note[i];
             }

             moyenne = moyenne / nb;
             alert("La moyenne est " + moyenne);
\end{Verbatim}                        
A la ligne 6, nous demandons, avec \instrcle{parseInt()}, la conversion d'une chaine vers un entier, car la fonction \texttt{prompt()} rend une chaine, et nous voulons traiter ce qu'a saisi l'utilisateur comme une valeur numérique. 
Nous faisons de même à la ligne 9.

\section{Calcul de distance}
Utilisation de {\tt for, Array, prompt()}.\\

Ecrire un programme qui, connaissant un ensemble de villes et la distance les séparant d'un point de référence, soit capable de dire, après que l'utilisateur ait saisi une distance parcourue depuis le point de référence, quelles villes auraient pu être atteintes.\\


\begin{Verbatim}[frame=single,numbers=left]
var villes =   new Array("Bordeaux","Nantes","Lyon",
                         "Marseille","Monptellier",
                         "Paris","Rennes","Strasbourg");
var distance = new Array(950,850,450,800,1000,460,840,0);
var dist;
        
     dist = parseInt(prompt("Entrer la distance parcourue : "),10);
     for (var i=0;i<villes.length;i++)
         if (dist>=distance[i])
	    alert("ville atteinte : " + villes[i]);
           
\end{Verbatim}
Supposons que le point de référence soit Strasbourg. 
Nous mettons alors dans la case 0 du tableau des distances, la distance séparant Strasbourg de la ville inscrite dans la case 0 du tableau des villes (Bordeaux). 
La boucle parcout ensuite le tableau des distances, et quand la distance parcourue est supérieure à l'éloignement de la ville, la ville correspondante est affichée.\\


\section{\'{E}criture de la fonction factorielle}
Utilisation de {\tt function, for}.\\

Ecrire une fonction qui, étant donné un paramètre $n$, supposé être
un entier positif, calcule et retourne sa factorielle.
Rappelons que la factorielle de $n$ est notée $n!$, et définie par :
$$
n! = \left\{ 
     \begin{tabular}{ll} 
        $n \times n-1 \times n-2 \times \ldots \times 1$  &  si $n>0$\\
	  $1$  & si $n=0$
	\end{tabular} 
	\right.
$$
En examinant la définition de factorielle, nous nous apercevons qu'il
faut effectuer $n$ multiplications. 
Nous allons procéder avec une boucle qui fera $n$ itérations, en énumérant
les entiers consécutifs de $n$ à $1$ à l'aide d'une variable $i$.
Concernant le calcul maintenant, 
la première étape doit nous donner comme résultat $n$. 
A la deuxième, nous devons obtenir le résultat de $n \times n-1$.
A la troisième, nous devons obtenir le résultat de $n \times n-1 \times n-2$,
c'est-à-dire le résultat calculé à la deuxième étape, multiplié par $n-2$. 

Par conséquent, nous allons mémoriser le résultat de chaque multiplication
dans une variable, que nous appelons ici \texttt{res}.
Nous initialisons cette variable à 1 (qui est l'élément neutre pour la
multiplication) et obtenons ainsi $n$ après la première multiplication.
A la deuxième étape, \texttt{i} vaut $n-1$, et nous multiplions donc
$n$ par $n-1$, résultat que nous remettons dans \texttt{res}.
A la fin de la boucle, nous avons fait les multiplications nécessaires,
et le résultat final est présent dans \texttt{res}.

Notons, que si $n=0$, nous ne rentrons pas dans la boucle, et \texttt{res}
vaudra 1.

\begin{Verbatim}[frame=single,numbers=left]
function factorielle( n ) {

    var res=1;
    for (i=n;i>=1;i=i-1) {
        res = res * i;
    }
    return(res);
}
\end{Verbatim}

\section{\'{E}criture de la fonction est premier}
Utilisation de {\tt function, while, modulo}.\\


Ecrire une fonction qui, étant donné un entier $a$, supposé être
un entier positif, dit si $a$ est un nombre premier.
Par définition, un nombre est premier s'il n'est divisible que par 
1 et par lui-même.\\

Nous utilisons une variable \texttt{b} qui sert à stocker touts les
entiers consécutifs entre $a-1$ et 2. Si le reste de la division
entre $a$ et cet entier est nul, cela signifie que cet entier
est un diviseur de $a$ et que $a$ n'est donc pas premier (par exemple
$a=6$ et l'entier est $3$). 
Remarquez la façon dont le reste d'une division entière est noté :
\texttt{a \% b} désigne le reste de la division de a par b, et on
le désigne habituellement par le terme \motcle{modulo}\index{\texttt{\%}}.

\begin{Verbatim}[frame=single,numbers=left]
function est_premier( a ) {
  var b;
  var prem=true;

  b = a-1;
  while (b>1 && prem) {
    if (a%b==0) prem = false;
    b--;
  }
  return(prem);
}
\end{Verbatim}


\section{Un rendeur de monnaie}
Utilisation de la notion de \motcle{partie entière} (\instrcle{parseInt()}).\\


Ecrire un programme qui, étant donné une somme $s$ introduite
(on suppose cette somme multiple de 0.1 \euro) 
dans une machine à café, et le prix d'un café $c$, indique
la composition de la monnaie rendue. On dispose de pièces de
1 , 0.5 , 0.2 et 0.1 \euro. 
On cherche à rendre le moins de pièces possibles.\\


Les variables \texttt{p1,p50,p20,p10} utilisées dans la solution
doivent stocker le nombre de pièces rendues pour chacune des valeurs.
L'algorithme repose sur l'observation simple suivante : si je dois rendre une
somme $r$ avec des pièces de valeur $v$, il faut $r/v$ pièces.
Si le reste de cette division est nul, la monnaie est rendue, sinon,
il reste à rendre $r' = r$\texttt{\%}$v$ (le reste de la division entière).
Par définition, on peut aussi calculer $r'$ comme ceci : $r' = r - (r/v)$.
si $r'$ n'est pas nul, on peut recommencer avec une valeur $v' (v'<v)$. 
Pour minimiser le nombre de pièces, 
on commence par compter le nombre de pièces nécessaires dans la plus forte valeur
(1 \euro). 
Dans le programme ci-dessous, est noté en commentaire la solution alternative
équivalente utilisant le modulo (ligne 8,10,12). 
Notez aussi qu'à la lgine 5, on s'est abstenu de diviser \texttt{a\_rendre} par 
la valeur de la pièce car elle est de 1 (élément neutre, donc division superflue).

\begin{Verbatim}[frame=single,numbers=left]
  var p1, p50, p20, p10;
  var a_rendre;
                                                                                
  a_rendre = s - c;
  p1 = parseInt(a_rendre);
  a_rendre = a_rendre - p1
  p50 = parseInt(a_rendre / .5);
  a_rendre = a_rendre - p50 * 0.5   // a_rendre = a_rendre % 0.5;   
  p20 = parseInt(a_rendre / .2);
  a_rendre = a_rendre - p20 * 0.2   // a_rendre = a_rendre % 0.2;
  p10 = parseInt(a_rendre / .1);
  a_rendre = a_rendre - p10 * 0.1   // a_rendre = a_rendre % 0.1;
  document.write("pièce de 1   E : ",p1,"<br/>");
  document.write("pièce(s) de 0.5 E : ",p50,"<br/>");
  document.write("pièce(s) de 0.2 E: ", p20,"<br/>");
  document.write("pièce(s) de 0.1 E: ", p10,"<br/>");
\end{Verbatim}

Notons que l'énoncé facilite le problème dans la mesure où l'on est toujours capable de rendre la monnaie. 
Le problème ne serait pas aussi simple si l'on n'avait pas de pièce de 0.1 \euro par exemple.
Dans ce cas en effet, notre programme ne pourrait pas rendre la monnaie sur 1.80 \euro (il donnerait 1 \euro + 1 $\times$ 0.50 + 1 $\times$ 0.20 et il manquerait 0.10) alors qu'on pourrait rendre la monnaie avec 9 $\times$ 0.20.

\section{Un rendeur de monnaie (général)}
Utilisation de la notion de \motcle{partie entière} et de \motcle{tableau} .\\


Ecrire un programme qui, étant donné une somme $s$ introduite
dans une machine à café, et le prix d'un café $c$, indique
la composition de la monnaie rendue. On dispose de $n$ types
de pièces de valeur stockées dans un vecteur 
$v = (v_1, \ldots v_i,v_{i+1}, \ldots , v_n)$.
Les valeurs sont classées par ordre décroissant, i.e. $v_i > v_{i+1}$.
Représenter la monnaie rendue par un vecteur $p=(p_0, \ldots, p_n)$
qui indique combien de pièces de chaque valeur il faut rendre.
La somme rendue est $\sum_{i=1}^n p_i \cdot v_i$. 
On cherche à rendre le moins de pièces possibles.\\


\begin{Verbatim}[frame=single,numbers=left]
 var v = new Array(1, 0.5 ,0.2, 0.1);  /* par exemple */
 var p = new Array();
 var a_rendre;
 var i;
 var fenetre;
 
 a_rendre = s - c;
 fenetre = window.open("","monnaie","width=200,height=200");
 fenetre.document.write("<html><body>");
 fenetre.document.write("Monnaie à rendre : ",a_rendre,"<br/>");
 for (i = 0; i < v.length  ; i=i+1) {
     p[i] = parseInt(a_rendre / v[i]);
     a_rendre = a_rendre - p[i]*v[i];
 }
 for (i = 0; i< v.length ; i=i+1)
     fenetre.document.writeln("pièce de ",v[i]," E: ",p[i],"<br/>");
 fenetre.document.writeln("</body></html>");
\end{Verbatim}




