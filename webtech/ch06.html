<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 6. Accéder à une base MySQL avec PHP</title><link rel="stylesheet" href="duaneg-docbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.71.1"><link rel="start" href="index.html" title="Notes de cours Apache+PHP+MySQL"><link rel="up" href="index.html" title="Notes de cours Apache+PHP+MySQL"><link rel="prev" href="ch05.html" title="Chapter 5. SQL"><link rel="next" href="ch07.html" title="Chapter 7. Fonctionnalités Récurrentes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. Accéder à une base MySQL avec PHP</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id36117770"></a>Chapter 6. Accéder à une base MySQL avec PHP</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch06.html#id36117794">Conseils pour le diagnostic d'erreur</a></span></dt><dt><span class="sect1"><a href="ch06.html#id36117847">Lecture et affichage HTML des données</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch06.html#lecture">Lecture des données</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36117987">Afficher les données</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36118046">Une autre façon de faire ...</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36118112">Programme complet</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch06.html#id36118147">Insertion de données dans la base</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch06.html#id36118161">Saisie des données (formulaire)</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36118218">Récupération des valeurs du formulaire HTML en PHP</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36118331">Ecriture des données (INSERT)</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36118394"> Modification de données (UPDATE)</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch06.html#id36118497">Gérer plusieurs tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch06.html#id36118535">L'exemple simple d'un forum</a></span></dt><dt><span class="sect2"><a href="ch06.html#id36118901">Exemple avec trois tables</a></span></dt></dl></dd></dl></div><p>
Examinons maintenant comment il est possible d'exploiter ces logiciels
pour fournir aux visiteurs, à la fois un affichage des produits présents
dans notre base de données, et un moyen pour le visiteur d'ajouter un nouveau
produit à cette base. Nous commençons avec un programme PHP qui doit nous 
permettre de générer une page HTML, sur laquelle figure un tableau des
produits avec leurs prix correspondants. Nous mettrons ce code dans le
fichier <code class="filename">lecture.php</code>.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id36117794"></a>Conseils pour le diagnostic d'erreur</h2></div></div></div><p>
Du fait des langages multiples utilisés, il est parfois difficile
d'identifier simplement la source d'un dysfonctionnement lors du développement des programmes.
</p><p>
Il est donc conseillé de manière générale, de ne pas faire l'économie des
tests d'erreurs. Par exemple, la tentative de connexion à une base devrait
prévoir l'échec de la connexion :
</p><pre class="programlisting">
@mysql_connect("$hostname", "$username", "$password")
      or die("Impossible de se connecter a la base");
</pre><p>
</p><p>
De même, pour toutes les requêtes MySQL, je conseille de définir une
fonction comme celle-ci :
</p><pre class="programlisting">
function teste_erreur($query) {
    $error = mysql_errno();
    $error_msg = mysql_error();
    if (!empty($error_msg)) {
        echo "L'erreur $error_msg s'est produite (code=$error)";
        echo "pour la requête $query\n";
    }
}
</pre><p>
et de l'appeler systématiquement après une requête <span><strong class="command">mysql_query($q)</strong></span> de façon à ne pas chercher trop longtemps la cause de l'erreur :

</p><pre class="programlisting">
   $q = " ..... "
   mysql_query($q);
   teste_erreur($q);
</pre><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id36117847"></a>Lecture et affichage HTML des données</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="lecture"></a>Lecture des données</h3></div></div></div><p>
Supposons que nous ayons une base de données appelée 
<code class="varname">base</code> comportant une table appelée 
<code class="varname">produit</code>. 
Notre première tâche est de demander à PHP de se connecter
à l'ordinateur sur lequel se trouve la base MySQL, puis
de préciser qu'on veut utiliser cette table :
</p><pre class="programlisting">
&lt;?
mysql_connect("localhost","root","") or die("Impossible de se connecter");;
mysql_select_db("base") or die("pas possible de trouver la base");
</pre><p>
Ici, nous spécifions que la base est sur l'ordinateur qui exécute le
script PHP (<code class="varname">localhost</code>), et qu'on se connecte
en tant qu'administrateur de la base (<code class="varname">root</code>), qui
n'a pas de mot de passe.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
Si votre base MySQL à été paramétrée différement, changez bien sûr les
paramètres (vérifier entre autres que vous n'avez pas besoin d'un mot
de passe).
</p></td></tr></table></div><p>

L'instruction <code class="function">die</code> permet d'arrêter le script avec un message d'erreur
en cas d'échec.
</p><p>
Demandons maintenant de lister toutes les informations de notre 
table <code class="varname">produit</code>. Il faut d'abord, à travers
PHP, faire une requête SQL qui permette de selectionner tous les
champs de la table (première ligne).

</p><pre class="programlisting">
$result = mysql_query("SELECT * FROM produit");
$nblignes = mysql_num_rows($result);
</pre><p>

Le résultat de cette requête est un tableau de données, comme les
deux dernières lignes du tableau suivant :
</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>ref</th><th>nom</th><th>prix</th></tr></thead><tbody><tr><td>1</td><td>canon bj10e</td><td>120</td></tr><tr><td>2</td><td>epson stylus 8c</td><td>135</td></tr></tbody></table></div><p> 

Nous devons traiter les lignes du tableau les unes après les
autres. Pour cela, nous avons besoin de connaître le nombre
de ligne de notre tableau. C'est ce qui est fait à la deuxième ligne
de l'extrait de code précédent, et le résultat est conservé dans <code class="varname">nblignes</code>.
Nous sommes maintenant prêt à afficher nos données présentes dans 
<code class="varname">result</code>, dans le format HTML.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36117987"></a>Afficher les données</h3></div></div></div><p>
Nous voulons présenter nos données sous la forme d'une table HTML.
Il faut donc faire écrire à PHP, le code HTML correspondant.
</p><p>
La première ligne de la table est constante : il s'agit de l'entête.
Ensuite, il faut extraire, pour chaque ligne de notre tableau,
les valeurs à afficher. Pour cela, nous extrayons pour chaque ligne 
<code class="varname">i</code> les valeurs des champs nom et prix de notre table,
avec la commande <span><strong class="command">mysql_result()</strong></span>. 
Celle-ci prend en argument la table, le numéro de ligne, et le nom de colonne
pour rendre la valeur correspondante dans la table.
Nous mettons les valeurs nom et prix de la table respectivement dans les variables 
PHP <code class="varname">$prod_nom</code> et <code class="varname">$prod_prix</code> 
(le nom de ces variables PHP est tout à fait 
arbitraire et n'a pas de relation avec le nom des colonnes SQL).
Quand les valeurs de la ligne ont
été récupérées, nous pouvons écrire la ligne correspondante du tableau HTML. 
Enfin, nous fermons la table quand toutes les lignes ont été examinées.

</p><pre class="programlisting">
 
    echo "&lt;table&gt;&lt;tr&gt;&lt;td&gt; Désignation &lt;/td&gt;&lt;td&gt; Prix &lt;/td&gt;&lt;/tr&gt;\n";
    for ($i=0;$i&lt;$nblignes;$i=$i+1) {
	 $prod_nom =  mysql_result($result,$i,"nom");
	 $prod_prix = mysql_result($result,$i,"prix");
	 echo "&lt;tr&gt;&lt;td&gt;$prod_nom&lt;/td&gt;&lt;td&gt;$prod_prix&lt;/td&gt;&lt;/tr&gt;";
    }
    echo "&lt;/table&gt;";

</pre><p>

</p><p>
Enfin, il nous faut par prudence refermer la base MySQL mais la quasi-totalité
du code PHP nécessaire à la consultation de notre table est écrit.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118046"></a>Une autre façon de faire ...</h3></div></div></div><p>
Nous avons utilisé dans la solution précédente une boucle pour 
passer en revue chaque ligne de la table de résultat obtenue par la 
requête SELECT. Le nombre de lignes de la table est donné par
<span><strong class="command">mysql_num_rows()</strong></span> et chaque élément est extrait 
avec <span><strong class="command">mysql_result()</strong></span>.
</p><p>
Une alternative un peu plus concise consiste à utiliser 
<span><strong class="command">mysql_fetch_array()</strong></span>.
Cette fonction prend en argument la table de résultat obtenue par la requête
(<code class="varname">$result</code> dans notre exemple), et
renvoie un tableau associatif correspondant à une ligne de la table.
L'indexation du tableau est faite avec les noms des colonnes de la table SQL.
Par exemple, si on récupère un tableau <code class="varname">$t</code> 
($t = mysql_fetch_array($result)),
et qu'un des champs SQL a pour nom <code class="varname">id</code>, alors on peut 
accéder à la valeur de la ligne lue par <code class="varname">$t['id']</code>.
La fonction gère un poineur interne: lors du premier appel, ce sont les éléments
de la première ligne qui sont mis en tableau. Chaque nouvel appel fait progresser 
le pointeur pour permettre de lire la ligne suivante.
</p><p>
Un équivalent au bout de code précédent est:
</p><pre class="programlisting">
 
      echo "&lt;table&gt;&lt;tr&gt;&lt;td&gt; Désignation &lt;/td&gt;&lt;td&gt; Prix &lt;/td&gt;&lt;/tr&gt;\n";
      while ($ligne = mysql_fetch_array($result)) {
   		echo "&lt;tr&gt;&lt;td&gt;" . $ligne['nom'] . "&lt;/td&gt;&lt;td&gt;". $ligne['prix']. "&lt;/td&gt;&lt;/tr&gt;";
      }
      echo "&lt;/table&gt;";

</pre><p>
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118112"></a>Programme complet</h3></div></div></div><p>
Récapitulons en listant maintenant le programme complet qui permet 
de lire le contenu
de notre table. Donnez une extension php à votre nom de fichier 
(<code class="filename">lecture.php</code> par exemple).

</p><pre class="programlisting">
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt; Catalogue produit&lt;/h1&gt;
&lt;?
mysql_connect("localhost","root","") or die("Impossible de se connecter");;
mysql_select_db("base") or die("pas possible de trouver la base");

$result = mysql_query("SELECT * FROM produit");
$nblignes = mysql_numrows($result);
    
echo "&lt;table&gt;&lt;tr&gt;&lt;td&gt;Désignation&lt;/td&gt;&lt;td&gt;Prix&lt;/td&gt;&lt;/tr&gt;\n";
for ($i=0;$i&lt;$nblignes;$i=$i+1) {
	 $prod_nom =  mysql_result($result,$i,"nom");
	 $prod_prix = mysql_result($result,$i,"prix");
	 echo "&lt;tr&gt;&lt;td&gt;$prod_nom&lt;/td&gt;&lt;td&gt;$prod_prix&lt;/td&gt;&lt;/tr&gt;";
}
echo "&lt;/table&gt;";
mysql_close();
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre><p>
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id36118147"></a>Insertion de données dans la base</h2></div></div></div><p>
Pour la mise à jour de la base nous avons besoin de deux fichiers :
un premier fichier qui doit contenr un formulaire HTML dans lequel l'internaute
peut saisir les données à insérer dans la base, et un deuxième fichier
(PHP) qui permette de récupérer les données du formulaire pour les insérer dans
la base.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118161"></a>Saisie des données (formulaire)</h3></div></div></div><p>
Ici, le fichier peut être un simple fichier HTML, puisque toutes les éléments de la page sont statiques.
Nous l'appelons <code class="filename">saisie.html</code>. 
Notez que la mise en page HTML est des
plus sommaires, ceci afin d'améliorer la lisibilité et se concentrer
sur les éléments importants du code.
</p><pre class="programlisting">
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;Mise à jour de la base&lt;/h1&gt;
&lt;form method="post" action="maj.php"&gt;
Référence : &lt;input type="text" name="ref"&gt;&lt;br&gt;
Nom       : &lt;input type="text" name="nom"&gt;&lt;br&gt;
Prix      : &lt;input type="text" name="prix"&gt;&lt;br&gt;
            &lt;input type=submit value="Insérer"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre><p>
</p><p>

Il est important de remarquer la partie <code class="function">action</code>
du formulaire. C'est ici qu'on précise quel programme doit
récupérer les données du formulaire et les traiter.
Dans notre cas, il s'agit du fichier <code class="filename">maj.php</code>,
qui sera chargé lorsque le bouton de type <code class="function">submit</code>
sera pressé.
</p><p>

Rappelons que toute cette section ne présente que des éléments connus
d'un programmeur HTML. Rien de nouveau !

</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118218"></a>Récupération des valeurs du formulaire HTML en PHP</h3></div></div></div><p>

Nous voulons mainteant récupérer les données du formulaires pour les insérer dans la base. 
Avant de l'écrire, il est d'abord nécessaire de savoir comment sont transmises
les données du formulaire à notre nouveau fichier (celui désigné par l'attribut <span><strong class="command">action</strong></span>
dans le formulaire précédent), et comment on peut récupérer ces valeurs en PHP.
</p><p>
Techniquement, le formulaire HTML est <span class="emphasis"><em>posté</em></span> lorsque l'utilisateur 
appuie sur le bouton de type <span><strong class="command">submit</strong></span> et que la balise <span><strong class="command">form</strong></span>
spécifie <span><strong class="command">method="post"</strong></span>.
Ceci veut dire qu'une requête HTTP de type POST est émise vers le serveur, 
et cette requête contient les valeurs du formulaire. 
La forme sous laquelle sont transmises les valeurs est une suite de couples 
(<span><strong class="command">variable</strong></span> = <span><strong class="command">valeur</strong></span>).
</p><p>
PHP récupère ces valeurs postées dans un tableau qu'il nomme <span><strong class="command">$_POST</strong></span>.
C'est un tableau associatif, dont les index de tableaux sont les noms des variables 
(voir le paragraphe sur les tableaux associatifs en PHP). 
Il est donc facile de retrouver la valeur associée à une variable.
Par exemple, <span><strong class="command">$_POST['prix']</strong></span> désigne la valeur associée au champ HTML <code class="varname">prix</code> 
dans le formulaire posté.
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
Dans les anciennes configurations de PHP (avant PHP 4.2.0), il n'était pas nécessaire de récupérer explicitement les variables postées. 
PHP créait automatiquemlent des variables PHP de même nom que les champs déclarés dans le forumaire HTML. 
Ainsi, on récupère la valeur du champ <span><strong class="command">&lt;input type="text" name="prix"&gt;</strong></span> du formulaire dans une variable <span><strong class="command">$prix</strong></span>.
Ce mode aujourd'hui désactivé pour des raisons de sécurité, peut être rétabli
en écrivant <span><strong class="command"> register_globals = On </strong></span> dans le fichier <code class="filename">php.ini</code>.
</p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118331"></a>Ecriture des données (INSERT)</h3></div></div></div><p>
Maintenant que nous savons récupérer les valeurs des variables du formulaire, 
il faut les sauvegarder dans la base de données.
</p><p>
Nous écrivons un deuxième fichier, que nous appelons <code class="filename">maj.php</code>.
Voyons le listing de notre fichier. 
On retrouve les instructions de connexion à la base, comme dans
<a href="ch06.html#lecture" title="Lecture des données">the section called “Lecture des données”</a>. 
Sur le principe, seule la requête SQL change, avec un 
<span><strong class="command">INSERT</strong></span> au lieu d'un <span><strong class="command">select</strong></span>.

</p><pre class="programlisting">
&lt;html&gt;
&lt;body&gt;
&lt;?
// connexion à la base
mysql_connect("localhost","root","") or die ("Impossible de se connecter");
mysql_select_db("base") or die("Impossible de trouver la base");           

// recuperation des valeurs du formulaire
$nom = $_POST['nom'];
$prix= $_POST['prix'];

// insertion des valeurs dans la base
$query = "INSERT INTO produit (nom,prix) VALUES ('$nom','$prix')";
$result=mysql_query($query);
mysql_close();
?&gt;
Mise a jour faite
&lt;/body&gt;
&lt;/html&gt;
</pre><p>

Ici, on suppose toujours que <code class="varname">ref</code> est une clé primaire
de la table produit, et qu'elle possède en plus la propriété <span><strong class="command">
autoincrement</strong></span>. 
Ainsi, nous n'avons pas à gérer l'unicité de la référence, puisque MySQL
inserera automatiquement une référence entière supérieure aux autres références
trouvées.

</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118394"></a> Modification de données (UPDATE)</h3></div></div></div><p>
La modification de données (on dit encore la mise à jour, ou le remplacement de valeur)
peut porter sur une ou plusieurs lignes, d'une ou plusieurs tables.
La modification en SQL se dit <span><strong class="command">UPDATE</strong></span>.
On indique les noms des colonnes concernées et les valeurs à y mettre (SET col1=valeur1, col2=valeur2, ...)
et à quelles lignes cela s'applique (WHERE condition).
</p><p>
Exemple: le nom d'un domaine informatique change de 'fly.com' à 'fly.org'. 
Je veux mettre à jour la colonne 'nondomaine' de ma table 'adresses' en conséquence.
La commande suivante modifiera toutes les lignes qui ont 'fly.com'.
</p><pre class="programlisting">
	  UPDATE adresses
	  SET nomdomaine='fly.org'
	  WHERE nomdomaine='fly.com'
</pre><p>
</p><p>
On peut aussi modifier plusieurs colonnes simultanément.
Par exemple, modifier dans la table 'adresses' l'email et le pseudo de l'utilisateur 
numéro 3 (uid=3) se dit: 
</p><pre class="programlisting">
        UPDATE adresses
	  SET email='newemail@fly.org', pseudo='newpseudo' 
        WHERE uid=3
</pre><p>
</p><p>
MySQL introduit une extension (ne faisant pas partie du standard SQL) 
permettant de modifier toute une ligne: <span><strong class="command">REPLACE</strong></span>.

</p><pre class="programlisting">
   REPLACE INTO  table 
           (champ1,champ2,...) 
    WHERE  (conditions)
    VALUES (val1,val2,...);
</pre><p>
qui remplace les valeurs présentes dans champ1 par val1, champ2 par val2, etc.
</p><p>
Cette commande est en fait une extension de la comande <span><strong class="command">INSERT</strong></span>.
Dans le cas ou l'un des champ est clé primaire de la table, et que la valeur
précisée existe déjà dans la table, alors cette ligne sera remplacée.
Si aucun enregistrement avec une telle valeur de clé n'existe, alors la ligne
sera insérée.
Ainsi, cette commande peut être utilisée à des fins d'insertion ou de remplacement.
</p><p> 
Reprenons notre exemple précédent. 
On veut modifier le prix d'un article dont on connait la référence, stockée dans
la variable $ref.
La référence est la clé primaire (colonne <code class="varname">ref</code>) de notre table
'lecteurs'.
Le remplacement va être opéré si la valeur présente dans $ref existe déjà
dans la table. 
</p><pre class="programlisting">
$query = "REPLACE INTO produit (ref,marque,modele,annee,prix) 
          VALUES ('$ref','$marque','$modele','$annee','$nouveau_prix')";
$ok = mysql_query( $query );
if ($ok) 
   echo "Le prix de l'article $ref est modifié ..."; 
</pre><p>

</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id36118497"></a>Gérer plusieurs tables</h2></div></div></div><p>
Nous n'avons jusqu'ici considéré que la base de données n'était constituée
que d'une table. 
Dans la réalité, la base de données est toujours constituée de plusieurs tables,
et il est donc naturel d'aller chercher, pour un élément d'une table, des
informations liées présentes dans d'autres tables.
</p><p>
Faire une sélection impliquant plusieurs tables implique un mécanisme plus 
difficile à comprendre. Une opération sur plusieurs table implique en général
de travailler sur le <span class="emphasis"><em>produit cartésien</em></span> des tables. 
Une opération fondamentale des bases de données relationnelle est la 
<span class="emphasis"><em>jointure</em></span> qui indique comment deux tables doivent
être mises en correspondance, et représente donc un sous-ensemeble du
produit cartésien.
</p><p>
Une bonne compréhension de ces mécanismes peut être acquise dans des ouvrages
traitant spécifiquement des bases de données relationnelles et de SQL.
Cependant, l'exemple simple suivant permet de schématiser ce processus.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118535"></a>L'exemple simple d'un forum</h3></div></div></div><p>
Dans un forum de discussions, on pourrait avoir par exemple les deux tables
suivantes: une table recensant les messages postés avec pour chaque message,
le numéro d'utilisateur l'ayant posté. Dans une table profils, on retrouverait
toutes les informations sur cet utilisateur.
</p><pre class="programlisting">
posts    (numpost,user,texte)    
profils  (user,pseudo,email)
</pre><p>
Un exemple simplifié de données pour de telles tables pourrait être:
</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>numpost</th><th>user</th><th>texte</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>Hello, does anybody knows what is SQL?</td></tr><tr><td>2</td><td>1</td><td>Hello again, anyone listening?</td></tr><tr><td>3</td><td>2</td><td>Hello, you'd better buy a book and read it.</td></tr></tbody></table></div><p> 
et
</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>user</th><th>pseudo</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>newbie555</td><td>newbie@hotmail.com</td></tr><tr><td>2</td><td>jobasher</td><td>jo.basher@gmail.com</td></tr></tbody></table></div><p> 
</p><p>
Pour l'affichage des messages, on veut bien sûr pouvoir associer au message 
le pseudo ou l'email de l'utilisateur ayant posté le message, ce qui demande
d'aller trouver, à partir de <code class="varname">numpost</code> le <code class="varname">pseudo</code>
correspondant. Par exemple, le post 3 (<code class="varname">numpost=3</code>) à été
posté par un utilisateur de pseudo jobasher.
</p><p>
On peut illustrer sur cet exemple simple, la requête SQL qui va nous permettre
d'obtenir le résultat. Etant donné un numéro de post (disons 3), on veut le pseudo 
associé tiré de la table <code class="varname">profils</code>:
</p><pre class="programlisting">
select pseudo
  from posts,profils
where
   numpost = 3 and 
   posts.user = profils.user
</pre><p>
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
   En SQL, un même nom de champ (de colonne) peut être utilisé dans plusieurs
   tables. Il devient donc ambigu quand ces tables sont utilisées en même temps.
   Pour lever l'ambiguité, il suffit de préfixer le nom du champ
   par le nom de sa table. Ici par exemple, on
   écrit <code class="varname">profils.user</code> pour préciser de quel
   champ <code class="varname">user</code> il s'agit.
</p></td></tr></table></div><p>
Pour comprendre cette jointure, on peut la représenter par le produit cartésien des deux tables,
sur lequel on va imposer des restrictions. 
Le produit cartésien des deux tables (développant toutes les combinaisons
de colonnes des deux tables) donnerait:
</p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>numpost</th><th>user</th><th>texte</th><th>user</th><th>pseudo</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>Hello, does anybody knows what is SQL?</td><td>1</td><td>newbie555</td><td>newbie@hotmail.com</td></tr><tr><td>1</td><td>1</td><td>Hello, does anybody knows what is SQL?</td><td>2</td><td>jobasher</td><td>jo.basher@gmail.com</td></tr><tr><td>2</td><td>1</td><td>Hello again, anyone listening?</td><td>1</td><td>newbie555</td><td>newbie@hotmail.com</td></tr><tr><td>2</td><td>1</td><td>Hello again, anyone listening?</td><td>2</td><td>jobasher</td><td>jo.basher@gmail.com</td></tr><tr><td>3</td><td>2</td><td>Hello, you'd better buy a book and read it.</td><td>1</td><td>newbie555</td><td>newbie@hotmail.com</td></tr><tr><td>3</td><td>2</td><td>Hello, you'd better buy a book and read it.</td><td>2</td><td>jobasher</td><td>jo.basher@gmail.com</td></tr></tbody></table></div><p> 

La jointure contraint ce résultat en spécifiant l'égalité des valeurs de deux des colonnes.
Ainsi, la seule ligne qui satisfait aux contraintes de notre requête est la dernière du tableau: 
<code class="varname">numpost=3</code> et <code class="varname">post.user</code> ainsi que 
<code class="varname">profils.user</code> sont égaux (2).
Le résultat à notre requête est donc la table:
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><thead><tr><th>pseudo</th></tr></thead><tbody><tr><td>jobasher</td></tr></tbody></table></div><p> 


</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id36118901"></a>Exemple avec trois tables</h3></div></div></div><p>
Prenons maintenant un autre exemple.
Imaginons que notre base est faite de trois tables : 
les tables clients, produits et commandes.
</p><pre class="programlisting">
clients (clid,nom)                          clé : clid
produits(pid,descr,prix)                    clé : pid
commandes(pid,clid,quantite,montant,date)   clé : pid,clid
</pre><p>
</p><p>
Pour lister les clients qui ont passé des commandes de plus de 2000 Euros
et afficher ce qu'ils ont commandé, on peut écrire la requête SQL
suivante :
</p><pre class="programlisting">
select client.nom,produits.descr 
  from produits,commandes,clients
where
   commandes.montant &gt;  2000  and
   commandes.pid=produits.pid and
   commandes.clid=clients.clid
</pre><p>
</p><p>
Pour se persuader que la commande <span><strong class="command">select</strong></span> précédente remplit 
bien notre objectif, paraphrasons la. 
Nous obtiendrons au final une table composée des colonnes
<code class="varname">client.nom</code> et <code class="varname">produits.descr</code>.
Dans la table <code class="varname">commandes</code> seules les lignes dont le
montant dépassent 2000 sont sélectionnées. A chacune de ces lignes
correspond un numéro de client <code class="varname">(commandes.clid)</code>.
Ne seront sélectionnées dans les autres tables que les lignes dont le 
numéro de client est égal à celui-ci. 
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. SQL </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 7. Fonctionnalités Récurrentes</td></tr></table></div></body></html>
