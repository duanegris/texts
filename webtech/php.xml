<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "file:///usr/share/xml/docbook/schema/dtd/4.4/docbookx.dtd">

<book>
<bookinfo>
<title>Notes de cours Apache+PHP+MySQL</title>
<authorgroup>
 <author>
    <firstname>Stephane</firstname><surname>Genaud</surname>
 </author>
</authorgroup>

<copyright><year>2006</year><holder>S. Genaud</holder></copyright>
</bookinfo>

<toc></toc>


<!-- Chapitre Intro -->
<chapter>
<title>Introduction</title>

<para>
Cette documentation en construction à pour objectif d'expliquer
la mise en oeuvre d'applications sur un serveur 
utilisant Apache, PHP et MySQL.
Elle n'est pas destinée à un public de spécialistes, et doit permettre
de comprendre le fonctionnement général de telles applications, à travers
des exemples simples.
</para>

<para>
Le lecteur doit cependant avoir certaines connaissances pour comprendre
les éléments présentés dans cette documentation. 
Le premier pré-requis est une bonne connaissance du langage HTML. 
Etant donné le panorama très large de
techniques présentées, certains chapitres ne seront pas développés 
(ou même pas écrits) et nécessiteront d'aller consulter des documents
annexes. 
Si les logiciels Apache, PHP et MySQL ne sont pas déjà installés chez vous, il vous faudra consulter les documentations adéquates pour leur installation
et configuration.

D'autre part, le langage de requête SQL ansi que le langage PHP ne 
sont pas décrit en détails ici. 
Pour maîtriser ces langages, il vous faudra vous reporter aux références
données dans le document.
</para>

</chapter>



<!-- Chapitre 1 -->
<chapter>
<title>Apache, PHP et MySQL</title>

<sect1>
<title>Les trois logiciels en bref</title>
<para>
Ces trois noms désignent des logiciels, installés sur le site
web (machine serveur), ayant chacun des rôles différents. 
Examinons le rôle de chacun d'entre eux.

<itemizedlist> 
<listitem> <para>
<ulink url="http://www.apache.org">
Apache
</ulink>
est le <emphasis>serveur web</emphasis>. 
Son rôle est d'écouter les requêtes émises par les navigateurs (qui demandent
des pages web), de chercher la page demandée et de la renvoyer.
</para></listitem>

<listitem> <para>
<ulink url="http://www.php.net">
PHP
</ulink>
est un <emphasis>langage de script</emphasis>. 
Il permet, de décrire dans une page web, un affichage dynamique d'information,
c'est-à-dire que le texte affiché peut dépendre de variables. 
Nous avons par exemple la possibilité d'afficher dans une page renvoyée au navigateur, la date du jour.
Les instructions PHP sont généralement contenues dans des fichiers 
d'extension php. Ces fichiers peuvent contenir du HTML, entremêlé avec
le code PHP. Quand un navigateur demande un tel fichier, le serveur Apache
exécute les instructions PHP, qui produisent une page HTML.
Une fois la page HTML générée, le serveur la renvoie au navigateur, qui
ne voit qu'une page HTML.
</para></listitem>

<listitem> <para>
<ulink url="http://www.mysql.com">
MySQL
</ulink>
est un <emphasis>système de gestion de base de données</emphasis>. 
Son rôle est de stocker les données, sous forme de tables, et de permettre
la manipulation de ces données à travers le langage de requête SQL.
Un exemple de requête peut être par exemple (exprimé en francais) 
: <quote>Lister les adresses des clients (à partir de la table client) qui
    ont acheté cette année pour plus de 1000 euros (à partir de la table facturation)</quote>. 
En SQL, cette requête s'écrirait par exemple de la manière suivante : 
<command>select (nom,adresse) from (client,facturation) where (client.numero = facturation.numero and facturation.total>1000)</command> 
où le champ <emphasis>numero</emphasis> est la clé primaire de chacune des 
tables, et représente le numéro de client.
</para>
<para>
PHP est capable de passer à MySQL de telles requêtes à travers les fonctions
de préfixe <function>mysql_</function> (PHP possède également des 
fonctions pour dialoguer avec d'autres systèmes de gestion de base de données).
C'est une raison du succès du couple PHP+MySQL dans la mise en place de
sites webs.
</para>
</listitem>
</itemizedlist>
</para>
<para>
L'utilisation des trois logiciels n'est nécessaire que lorsqu'on
veut afficher au visiteur des informations provenant de la base
de données. Cependant, cette configuration est fréquement utilisée
car elle correspond à beaucoup de besoins.
Un magasin voulant afficher à ses clients la liste de ses produits 
en stock, un forum de discussions permettant à des internautes
de lire, et rechercher des messages, sont autant d'exemples
d'application nécessitant la manipulation (enregistrement, manipulation,
affichage) de données à travers le réseau.
</para>
</sect1>
<sect1>
<title>Architecture 3-tiers</title>
<para>
La configuration que l'on met ici en place est souvent nommée "3-tiers" (3-tier en anglais) car
on peut décomposer fonctionnellement notre application en 3 couches distinctes.
<itemizedlist> 
<listitem> <para>
   <emphasis>couche présentation:</emphasis>
   c'est la partie de l'application visible par les utilisateurs (on parle d'interface utilisateur). 
   Dans notre cas, elle se présentera sous la forme de pages HTML, composée de formulaires, bouttons, etc. 
   Un exemple concret peut être l'interface de recherche de vols sur un site de réservation d'une compagnie aérienne: 
   la couche de présentation définit le formulaire de recherche et la présentation des résultats de la recherche.
<figure id="flightsearch_form">
<title>Exemple d'interface pour une recherche de vols</title>

<screenshot>
<screeninfo></screeninfo>
<graphic format="PNG" fileref="fligthsearch_form_shot.png"/>
</screenshot>
</figure>


   </para>
</listitem>
<listitem> <para>
    <emphasis>couche métier:</emphasis>
    c'est la "logique" de l'application elle-même, c'est-à-dire les algorithmes implémentés pour remplir les fonctions spécifiées.
    Dans l'exemple de la fonction de recherche de vols, l'application prendra les données saisies par l'utilisateur dans le formulaire,
    pourra vérifier la cohérence des informations demandées, mettre cette requête dans un format adéquat, et transmettre la requête
    au gestionnaire des données (couche accès aux données). 
    Si l'utilisateur attend des données en résultat, l'application procède en général à un traitement avant de les passer
    à la couche présentation.</para> 
</listitem>
<listitem> <para>
    <emphasis>couche accès aux données:</emphasis> c'est la partie qui gère les données. 
La façon dont elle organise, manipule, stocke, etc, les données est transparente aux applications ou utilsiateurs externes,
toutes ces opérations étant internes à la couche d'accès aux données.
Cette couche est souvent implantée avec un sytème de gestion de base de données. 
L'interface proposée est souvent SQL.
</para>
</listitem>
</itemizedlist>
Remarquons bien que le choix de Apache+PHP+MySQL n'en est que partie une multitude d'autres possibles.
(Par exemple Java/RMI+Base de données).


<figure id="fg1">
<title>Architecture 3-tiers avec Apache+PHP+MySQL</title>
<screenshot>
<screeninfo>Architecture 3-tiers</screeninfo>
<graphic format="PNG" fileref="webserver-3tier.png"/>
</screenshot>
</figure>

</para>
</sect1><!-- end archi -->

<sect1>
<title>Installation Linux</title>

<para>
L'installation sur un système Linux de ces trois composants est 
plutôt simple, étant donné que ces logiciels sont généralement
disponibles sur les CDs livrés par la plupart des distributions.
Nous prenons ici deux exemples de distribution. 
<ulink url="http://www.linux-mandrake.com">Mandrake 8</ulink>.
</para>

<para>
Dans cette distribution, Il vous faut installer les packages suivants :
<programlisting>
apache-common-1.3.19-3mdk
apache-modules-1.3.19-3mdk
apache-1.3.19-3mdk
apache-conf-1.3.19-3mdk
apache-mod_perl-1.3.19_1.25-3mdk
apache-suexec-1.3.19-3mdk
php-mysql-4.0.4pl1-6mdk
php-common-4.0.4pl1-6mdk
mod_php-4.0.4pl1-6mdk
php-4.0.4pl1-6mdk
php-mysql-4.0.4pl1-6mdk
MySQL-shared-3.23.36-2mdk
MySQL-client-3.23.36-2mdk
MySQL-3.23.36-2mdk
</programlisting>

De plus, on vérifiera que la configuration de PHP permet bien
d'accéder aux fonctions MySQL : 
visualiser le fichier <filename>/etc/php.ini</filename>
et vérifier que la ligne :
<programlisting>
extension = mysql.so
</programlisting>
est décommentée (il ne doit pas y avoir de points virgule en début de ligne).
</para>

<para>
Bien sûr, il faut aussi vérifier que les services Apache et MySQL sont
actifs. Dans le doute démarrez les (en tant que root):
<screen>
  <prompt>bash # </prompt><userinput>service httpd start</userinput>
  Starting httpd:                                            [  OK  ]
  <prompt>bash # </prompt><userinput>service mysql start</userinput>
  Starting mysqld daemon with databases from /var/lib/mysql
  <prompt>bash # </prompt>
</screen>
</para>
</sect1>


<sect1>
<title>Installation Windows</title>

<para>
L'installation sur les systèmes Windows de ces trois logiciels est aussi très populaire.
A tel point que les trois logiciels sont parfois proposés en un
seul paquet : le projet
<ulink url="http://www.easyphp.org/">
EasyPHP
</ulink>
livre une installation "clés-en-mains" de Apache, PHP, MySQL et de phpMyAdmin en prime.
La procédure d'installation de ce paquet est très simple. Reportez vous à la section téléchargement et installation de ce site ; vous devriez pouvoir avoir un environnement fonctionnel très rapidement.
</para>
</sect1>

</chapter>

<!-- Chapitre PHP -->
<chapter>
<title>PHP</title>

<para>
PHP est un langage interprété exécuté du côté serveur (comme les scripts CGI, ASP, ...) 
et non du côté client (par exemple un code Javascript ou une applet Java s'exécute sur votre ordinateur...). 
La syntaxe du langage est inspirée de celles du langage C, du Perl et de Java. 
</para>
<para>
La grande force de tels langages (PHP ou ASP) réside dans les fonctionnalités
de programmation qu'ils offrent pour traiter des problèmes liés au 
developpement de services web. 
Par exemple, des fonctions de traitements de chaînes de caractères puissantes
sont fournies.
Une autre grande classe de besoin pour les développements web concerne
l'utilisation de base de données. PHP propose une interface vers de
nombreux gestionnaires de bases de données, permettant au programmeur
d'accéder à un système de gestion de base de données à travers des
primitives du langage. 
PHP supporte des interfaces vers les bases de données suivantes :
Adabas D, dBase, Empress, FilePro, Hyperware, IBM DB2, Informix, Ingres, Interbase, Frontbase, 
Direct MS-SQL, mSQL, MySQL, Oracle (version 7 et 8), Ovrimos, PostgreSQL, Sesam, Solid, Sybase, Velocis et Unix dbm.
Quand une base de données n'est pas interfacée, il est en outre possible
d'utiliser le format ODBC.
</para>
									  
<sect1>
<title>Les opérateurs</title>

<para>
Les exemples donnés supposent que la valeur de <varname>$x</varname>
 est 8, <varname>$c</varname>  est "la ", et <varname>$b</varname> est TRUE;
</para>

<sect2>
<title>Opérateurs sur les nombres</title>

<para>
<informaltable>
<tgroup cols="4">
<thead>
<row>
<entry>opérateur</entry><entry>dénomination</entry>
<entry>exemple</entry><entry>résultat</entry>
</row>
</thead>
<tbody>
<row>
<entry>+</entry><entry>addition</entry>
<entry>$x+4</entry><entry>12</entry>
</row>
<row>
<entry>-</entry><entry>soustraction</entry>
<entry>$x-4</entry><entry>4</entry>
</row>
<row>
<entry>*</entry><entry>multiplication</entry>
<entry>$x*3</entry><entry>24</entry>
</row>
<row>
<entry>/</entry><entry>division</entry>
<entry>$x/2</entry><entry>4</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

<sect2>
<title>Opérateurs booléens</title>
<para>

<informaltable>
<tgroup cols="4">
<tbody>
<row>
<entry>|| ou OR</entry><entry>OU logique</entry>
<entry>$b OR FALSE</entry><entry>TRUE</entry>
</row>
<row>
<entry>|| ou OR</entry><entry>OU logique</entry>
<entry>$b OR FALSE</entry><entry>TRUE</entry>
</row>
<row>
<entry>&amp;&amp; ou AND</entry><entry>ET logique</entry>
<entry>$b AND TRUE</entry><entry>TRUE</entry>
</row>
<row>
<entry>XOR</entry><entry>OU exclusif</entry>
<entry>$b XOR FALSE</entry><entry>FALSE</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

<sect2>
<title>Affectation et affection combinées</title>
<para>

<informaltable>
<tgroup cols="4">
<tbody>
<row>
<entry>=</entry><entry>affectation</entry>
<entry>$x=5</entry><entry>$x==5</entry>
</row>
<row>
<entry>+=</entry><entry>incrémentation et affectation</entry>
<entry>$x+=6</entry><entry>$x==14</entry>
</row>
<row>
<entry>-=</entry><entry>soustraction</entry>
<entry>$x-=6</entry><entry>$x==2</entry>
</row>
<row>
<entry>/=</entry><entry>division</entry>
<entry>$x/=2</entry><entry>$x==4</entry>
</row>
<row>
<entry>%=</entry><entry>division entière</entry>
<entry>$x%=3</entry><entry>$x==2</entry>
</row>
<row>
<entry>|=</entry><entry>effectue un OU logique</entry>
<entry>$b |= FALSE</entry><entry>$b==TRUE</entry>
</row>
<row>
<entry>^=</entry><entry>effectue un OU exclusif logique</entry>
<entry>$b ^= FALSE</entry><entry>$b==TRUE</entry>
</row>
<row>
<entry>&amp;=</entry><entry>effectue un ET logique</entry>
<entry>$b &amp;= FALSE</entry><entry>$b==FALSE</entry>
</row>
<row>
<entry>.=</entry><entry>concatène la chaîne à droite à celle de gauche</entry>
<entry>$c .= "fin"</entry><entry>$c=="la fin"</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>


<sect2>
<title>Opérateurs de comparaison</title>
<para>
<informaltable>
<tgroup cols="4">
<tbody>
<row>
<entry>!=</entry><entry>différent</entry>
<entry>$x!=10</entry><entry>TRUE</entry>
</row>
<row>
<entry>==</entry><entry>égalité</entry>
<entry>$x==10</entry><entry>FALSE</entry>
</row>
<row>
<entry>&lt;=</entry><entry>inférieur ou égal</entry>
<entry>$x&lt;=10</entry><entry>TRUE</entry>
</row>
<row>
<entry>&lt;</entry><entry>inférieur</entry>
<entry>$x&lt;10</entry><entry>TRUE</entry>
</row>
<row>
<entry>>=</entry><entry>supérieur ou égal</entry>
<entry>$x>=10</entry><entry>FALSE</entry>
</row>
<row>
<entry>></entry><entry>supérieur</entry>
<entry>$x>10</entry><entry>FALSE</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

</sect1>

<!-- _______________________ T A B L E A U X __________________________ -->
<sect1>
<title>Les tableaux</title>
<para>
Les tableaux PHP sont des tableaux <emphasis>associatifs</emphasis>, 
c'est-à-dire que ce sont des listes d'associations entre une clé
et une valeur. Cette notion est plus générale que celle de tableau
simple que l'on rencontre habituellement : les tableaux simples
associent uniquement des positions (mémoire) à une valeur.
On accède habituellement dans ce cas, à un élément du tableau par une
notation crochet : t[i] désigne le i-ème élément du tableau (i entier).
</para>
<para>
Le tableau simple est un cas particulier du tableau associatif (où la clé
est la position dnas le tableau). Par conséquent PHP autorise bien sûr
l'utilisation de tableaux simples.
</para>

<sect2>
<title>Enumérations</title>

<para>
Un tableau peut servir à énumérer un ensemble fixe d'éléments.
Dans ce cas, le tableau PHP est créé avec la primitive <command>array()</command>
<programlisting>
   array( [clé =>] valeur , ... )
</programlisting>

où <varname>clé</varname> est une chaîne ou un entier, 
<varname>valeur</varname> peut être de n'importe quel type.
</para>
<para>
La clé est optionnelle, si bien qu'on que si l'on ne la précise
pas, on obtient un tableau simple. Dans ce cas, une numérotation
implicite des éléments de tableau à partir de 0 prend place.
</para>

<para>Voici deux exemples de d&eacute;claration de tableaux :
<programlisting>
$t1 = array( 'version' => 4 , 
             'OS'      => 'Linux',
             'name'    => 'app1');

$t2 = array( 'pierre',
             'jean',
             'max');
</programlisting>
</para>
<para>
Dans la deuxième déclaration, les éléments ont automatiquement
un clé qui est le numéro de l'élément. Dans ce cas, t2[1] désigne
la chaîne 'jean'.
Dans la première déclaration, on peut accéder aux éléments par une
notation comme : t1['OS'], qui vaut 'Linux'.
</para>
</sect2>

<sect2>
<title>Déclaration et affectation</title>
<para>
A l'instar des autres variables, on ne déclare pas les tableaux en PHP.
L'interpréteur PHP infère qu'une variable est de type tableau dès que la notation
crochets ( [ ] ) est utilisée.
</para>
<para>
L'affectation se fait directement avec la notation crochets, sans avoir besoin d'allouer
explicitement d'espace mémoire pour le stockage :
<programlisting>

 $tableau[0]="msg1";

</programlisting>
</para>
</sect2>

<!-- ********************** Parcours de tableau ********************************* -->
<sect2>
<title>Parcours</title>

<para>
Habituellement, dans un langage impératif, le parcours d'un tableau
est décrit par une boucle allant du premier indice au dernier indice
du tableau. En PHP, on peut aussi utiliser cette construction (on fait appel à la primitive
<command>count()</command> qui donne le nombre d'éléments d'un tableau) :
<programlisting>
 for ($i=0;$i&lt;count($t2);$i++) {
     echo "$t2[$i]";
 }
</programlisting>
</para>
<para>
Il existe cependant des primitives plus élaborées.
</para>
<para>
Ces primitives utilisent en interne un pointeur qui indique
où en est le parcours du tableau. Ce pointeur est invisible et
inaccessible au programmeur. La fonction <command>reset($tableau)</command>
permet de remettre le pointeur au début du tableau.
</para>

<para>
On peut utiliser la fonction <command>each($tableau)</command> qui prend
prend l'élément présent à la position courante du pointeur et le renvoie.
Le pointeur progresse automatiquement à la prochaine position du tableau.

<programlisting>
 reset($t2);
 while ($valeur = each($t2)) {
    echo "Valeur: $valeur";
  }
</programlisting>
Attention, si le tableau est associatif (comme <varname>$t1</varname>),
i.e. chaque élément est une paire
(clé,valeur), c'est cette paire qui est renvoyée par <command>each()</command>.
Pour lister les valeurs uniquement, on peut utiliser <command>list()</command>
qui permet de ne sélectionner que certains éléments d'un n-uplet.
</para>
<para>
<programlisting>
 reset($t1);
 while (list(, $valeur) = each($t1)) {
    echo "Valeur: $valeur";
  }
</programlisting>
</para>
<para>
La fonction <command>foreach()</command> est bien adaptée au parcours
d'un tableau, quelque soit le type de clé utilisé. 
On extrait les valeurs associées aux clés directement avec quelquechose
comme :
<programlisting>
  foreach($t1 as $valeur) {
    echo "Valeur: $valeur";
  }
</programlisting>
</para>
<para>
Tandis qu'on peut accéder à la fois à la clé et à la valeur de la manière
suivante :
<programlisting>
  foreach($t1 as $cle => $valeur) {
    echo "A $cle est associé $valeur";
  }
</programlisting>
</para>


</sect2>
</sect1>

<!-- _________________________ functions ____________________ -->
<sect1>
<title>Les fonctions</title>
<para>
Les fonctions permettent de définir un traitement retournant 0 ou 1 résultat.
On donne une fois sa définition, et on peut ensuite <emphasis>appeler</emphasis>
cette fonction autant de fois qu'on le désire dans d'autres parties du programme,
éventuellement avec des paramètres différents. 
</para>
<sect2>
<title>Définition d'une fonction</title>
<para>
Une fonction est définie par le mot clé <code>function</code>.
Le résultat retourné (optionnel) est celui donné par <code>return</code>.
<programlisting>
&lt;php?
function prix_reduit( $prix, $reduction ) {
   $res = $prix * (1-$reduc);
   return( $res);
}
?&gt;
</programlisting>
</para>
</sect2>
<sect2>
<title>Appel d'une fonction</title>
<para>
Une fois définie, la fonction peut être appelée, c-a-d exécutée 
(avec des paramètres réels si la définition attend des paramètres).
<programlisting>
&lt;php?
   ...
   $prix_initial=100;
   $reduc=0.20;
   $prix_final1 = prix_reduit( $prix_initial, $reduc );
   $prix_final2 = prix_reduit( 100 , 0.20 );
   ...
?&gt;
</programlisting>
Les deux appels à <code>prix_reduit</code> ci-dessus donnent le même résultat.
</para>
</sect2>


<sect2>
<title>Exemple de fonction</title>
<para>
On se servira avec avantage des fonctions pour éviter les traitements répétitifs.
Par exemple, on pourra écrire une fonction qui fait une requête SQL passée en paramètre,
et qui accepte un paramètre supplémentaire (debug) quand on veut plus d'information
sur les erreurs.

<programlisting>
function requete($requet, $debug=0) {
      if($debug==0){
            $query = mysql_query($requet);
            if($query == 0)
                  echo "Problème d\'accès à la base de données ou erreur de syntaxe dans la requête.";
            return $query;
      }
      // mode debug
      else{
            $query = mysql_query($requet);
            echo "$requet";
            if($query == 0) {
                  echo "Problème d\'accès à la base de données ou erreur de syntaxe dans la requête.";
                  echo "Erreur #'. mysql_errno()";
                  echo "Description : ' . mysql_error()";
            }
            else
                  echo "Pas d\'erreur dans la requête.";
            return $query;
      }
}
</programlisting>
</para>

</sect2>



</sect1>
</chapter>


<!-- _______________ Chapitre  PHP et HTML ______________________________ -->
<chapter>
<title>Passage de valeurs d'une page à l'autre</title>

<para>
La notion de site web <emphasis>dynamique</emphasis> repose sur l'interactivité,
et donc la capacité du client à envoyer, avec son navigateur, des données au service web.
Les méthodes principales pour envoyer les données sont:
</para>
<itemizedlist>
	<listitem><para>L'utilisattion d'un formulaire HTML (méthode POST),</para></listitem>
	<listitem><para>L'utilisation d'une URL (méthode GET).</para></listitem>
</itemizedlist>

<sect1>
<title>Méthode POST</title>

<para>
Les moyens de saisir des données en HTML sont habituellement consignés
à l'intérieur d'un <emphasis>formulaire</emphasis> (form). 
Les balises HTML disponibles sont <varname>input</varname>, <varname>select</varname> ou <varname>textarea</varname>.
La balise <varname>input</varname> a de nombreuses variantes (attribut <varname>type</varname>= text, password, file, hidden, radio, checkbox ...
</para>

<para>
Le principe de passage des valeurs est le suivant.
Quand un formulaire comme ci-dessous est posté (<varname>method='post'</varname> comme attribut de <varname>form</varname>)
à l'aide du bouton submit,
le navigateur transmet les valeurs saisies dans le formulaire à l'URL
spécifiée dans l'attribut <varname>action</varname>.
Dans notre cas, l'URL de destination est un programme PHP ('maj.php' dans l'exemple)..
<programlisting>
&lt;form method="post" action="maj.php"&gt;

Champ texte : &lt;input type="text" name="monchamp"&gt;&lt;br&gt;

            &lt;input type=submit value="Insérer"&gt;
&lt;/form&gt;
</programlisting>

</para>

<para>
PHP met à disposition les valeurs saisies dans une variable <varname>$_POST</varname>.
Cette variable est un tableau associatif qui contient en particulier toutes les valeurs
saisies dans les champs du formulaire. 
Quand il y a un champ nommé <varname>monchamp</varname> dans le formulaire posté, on peut
récupérer la valeur saisie en PHP par 
<programlisting>
  $une_variable_php =  $_POST['monchamp'];
</programlisting>
</para>

</sect1>

<sect1>
<title>Méthode GET</title>

<para>
La méthode GET permet de récupérer des valeurs passées dans l'URL.
La partie de l'URL contenant les  paramètres passés est celle suivant le point d'interrogation (?).
Ensuite, chaque paramètre et sa valeur sont séparés par un ET commercial (&amp;).
Dans l'URL suivante, on a deux paramètres <varname>a</varname> et <varname>b</varname>
qui valent respectivement 23 et toto.
<programlisting>
  http://domaine.org/maj.php?a=23&amp;b=toto 
</programlisting>
</para>
<para>
PHP met à disposition les valeurs des paramètres présents dans une URL à travers une  <varname>$_GET</varname>.
Dans l'exemple précédent, on peut récupérer la valeur du paramètre <varname>a</varname> par:
<programlisting>
  $une_variable_php =  $_GET['a'];
</programlisting>
</para>

<tip>
<para>
La tâche de transférer les valeurs dans $_POST et $_GET (et les autres, moins utilisées) étant fastidieuse,
on peut demander à PHP une extraction automatique grâce à la fonction <command>extract()</command>. 
Elle exporte votre tableau associatif et crée une variable pour chaque clé du tableau.
</para>
<para>
Par exemple, si le tableau $_POST contient les variables <varname>login</varname> et <varname>email</varname>
<programlisting>
extract($_POST,EXTR_OVERWRITE);
</programlisting>
créera les deux variables PHP <varname>$login</varname> <varname>$email</varname>.
</para>
</tip>


</sect1>

<sect1>
<title>Autres variables systèmes</title>

<para>
</para>
</sect1>

</chapter>

<!-- ___________________________ Chapitre S Q L _______________ -->
<chapter>
<title>SQL</title>


<para>
SQL (Structured Query Language) est un langage de définition, de contrôle et de manipulation de données 
pour les bases de données relationnelles. 
Le modèle relationnel a été inventé par E.F. Codd (Directeur de recherche du centre IBM de San José) en 1970,
 et est devenu aujourd'hui le standart en terme de langage pour les bases de données.
 De fait, c'est le langage utilisé par le système de gestion de base de données
 MySQL.
</para>
<para>
Nous ne donnons ici qu'un aperçu du langage SQL, permettant de comprendre
les grands principes du langage et de réaliser des requêtes élémentaires.
Pour plus de détails, on pourra se reporter à la documentation
<ulink url="http://www.commentcamarche.net/sql/sqlsel.php3">
comment ça marche.
</ulink>
</para>

<sect1>
<title>Manipulation des données</title>

<para>
SQL est à la fois un langage de manipulation de données et un langage de définition de données. 
Toutefois, la définition de données est l'oeuvre de l'administrateur de la base de données, c'est pourquoi la plupart des personnes qui utilisent le langage SQL ne se servent que du langage de manipulation de données, permettant de sélectionner les données qui les intéresse. 
</para>


<sect2>
<title>Lire des données dans la base : SELECT</title>

<para>
     La principale commande du langage de manipulation de données est la 
     commande <function>SELECT</function>, dont la syntaxe est la suivante :  

     <programlisting>
		 SELECT [ALL] | [DISTINCT] &lt;liste des noms de colonnes&gt; 
		              | * FROM &lt;Liste des tables&gt; [WHERE &lt;condition logique&gt;] 
     </programlisting>

</para>
<para>
<itemizedlist> 
     <listitem><para> 
     L'option ALL (option par défaut) permet de sélectionner 
     l'ensemble des lignes satisfaisant à la condition logique
     </para></listitem>
     <listitem> <para>
     L'option DISTINCT permet de ne conserver que des 
     lignes distinctes, en éliminant les doublons 
     </para></listitem>
     <listitem><para>                         
     La liste des noms de colonnes indique la liste des 
     colonnes choisies, séparées par des virgules.
     </para></listitem>
     <listitem> <para>
     Lorsque l'on désire sélectionner l'ensemble des colonnes 
     d'une table il n'est pas nécessaire de saisir la liste 
     exhaustive de ses colonnes : l'option * permet de réaliser cette tâche 
     </para></listitem>
     <listitem> <para>
     La liste des tables indique l'ensemble des tables 
     (séparées par des virgules) sur lesquelles on opère
     </para></listitem>
     <listitem> <para>
     La condition logique permet d'exprimer des 
     qualifications complexes à l'aide d'opérateurs 
     logiques et de comparateurs arithmétiques 
     </para></listitem>
</itemizedlist>  
<tip>
<para>
        Le langage SQL n'est pas sensible à la casse 
	  (en anglais case sensitive), cela signifie que l'on peut aussi 
	  bien écrire les instructions en minuscules qu'en majuscule. 
	  Toutefois, cette insensibilité à la casse n'est que partielle 
	  dans la mesure où la différenciation entre minuscules et 
	  majuscules existe au niveau des identificateurs d'objets. 
</para>
</tip>
</para>
</sect2>


<sect2>
<title>Exemples SELECT</title>

<para>
        Voyons quelques unes des possibilités de la 
	  commande <function>SELECT</function>. 
        Supposons l'existence de la table suivante, recensant des 
	  lecteurs de CD
        vendus d'occasion. 
	  Cette table s'appelle <varname>lecteurs</varname>.
</para>
<informaltable>
<tgroup cols="5">
<thead>
<row>
<entry>ref</entry><entry>marque</entry><entry>modele</entry>
<entry>annee</entry><entry>prix</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>Pioneer</entry><entry>CD-120</entry>
<entry>1998</entry><entry>700</entry>
</row>
<row>
<entry>2</entry><entry>Sony</entry><entry>PL135</entry>
<entry>1999</entry><entry>890</entry>
</row>
<row>
<entry>3</entry><entry>Pioneer</entry><entry>CD-140</entry>
<entry>1997</entry><entry>950</entry>
</row>
<row>
<entry>4</entry><entry>Philips</entry><entry>PH340</entry>
<entry>2000</entry><entry>1050</entry>
</row>
<row>
<entry>5</entry><entry>Technics</entry><entry>T600</entry>
<entry>1998</entry><entry>890</entry>
</row>
</tbody>
</tgroup>
</informaltable> 
<para>
Nous pouvons lister l'ensemble de la table par 
<programlisting>
SELECT * FROM lecteurs
</programlisting>
qui nous donne tous les enregistrements de la table (cinq lignes).
Maintenant, nous pouvons restreindre la liste aux lecteurs ayant un prix
inférieur ou égal à 1000F :
<programlisting>
SELECT * FROM lecteurs WHERE prix &lt;= 1000
</programlisting>
<informaltable>
<tgroup cols="5">
<thead>
<row>
<entry>ref</entry><entry>marque</entry><entry>modele</entry>
<entry>annee</entry><entry>prix</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>Pioneer</entry><entry>CD-120</entry>
<entry>1998</entry><entry>700</entry>
</row>
<row>
<entry>2</entry><entry>Sony</entry><entry>PL135</entry>
<entry>1999</entry><entry>890</entry>
</row>
<row>
<entry>3</entry><entry>Pioneer</entry><entry>CD-140</entry>
<entry>1997</entry><entry>950</entry>
</row>
<row>
<entry>5</entry><entry>Technics</entry><entry>T600</entry>
<entry>1998</entry><entry>890</entry>
</row>
</tbody>
</tgroup>
</informaltable> 
On peut également combiner plusieurs critères.
Par exemple, les lecteurs Pioneer à moins de 1000F.
<programlisting>
SELECT * FROM lecteurs WHERE prix &lt; 1000 and marque='Pioneer'
</programlisting>

On peut aussi vouloir sortir cette liste après l'avoir trié.
La requête SELECT permet cela directement. 
Pour obtenir la liste des lecteurs classés par ordre de prix,
nous demandons :
<programlisting>
SELECT * FROM lecteurs ORDER BY prix 
</programlisting>
</para>
<para>
Quand on ne précise pas si le tri est croissant ou décroissant,
c'est un tri décroissant qui est opéré. 
On peut préciser de quel type est le tri à l'aide des mots clés
<varname>ASC</varname> (croissant) ou <varname>DESC</varname> (décroissant).
</para>
<para>
On peut aussi utiliser plusieurs critères de tri. 
Il suffit alors de séparer les noms des colonnes utilisées pour le
tri par des virgules. L'ordre dans lequel apparaissent les 
noms de colonnes indique quels critères sont prioritaires.
Par exemple,

<programlisting>
SELECT * FROM lecteurs ORDER BY prix,annee 
</programlisting>

donne la liste suivante, où quand plusieurs prix sont identiques,
le second critère (l'année) est utilisé pour déterminer l'ordre.
<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>ref</entry><entry>marque</entry><entry>modele</entry>
<entry>annee</entry><entry>prix</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>Pioneer</entry><entry>CD-120</entry>
<entry>1998</entry><entry>700</entry>
</row>
<row>
<entry>5</entry><entry>Technics</entry><entry>T600</entry>
<entry>1998</entry><entry>890</entry>
</row>
<row>
<entry>2</entry><entry>Sony</entry><entry>PL135</entry>
<entry>1999</entry><entry>890</entry>
</row>
<row>
<entry>3</entry><entry>Pioneer</entry><entry>CD-140</entry>
<entry>1997</entry><entry>950</entry>
</row>
<row>
<entry>4</entry><entry>Philips</entry><entry>PH340</entry>
<entry>2000</entry><entry>1050</entry>
</row>
</tbody>
</tgroup>
</informaltable> 


</para> 
</sect2>
</sect1>
<!-- Gestion : phpmyadmin  -->
<sect1>
<title>Gestion des données</title>
<para>
      La gestion des données comprend la création des bases et des tables,
	ainsi que la définition des champs des tables et leurs types.
	Toutes ces opérations peuvent se faire à l'aide de commandes
	MySQL.
</para>
<para>
	Cependant, pour écourter la présentation, nous recommandons l'utilisation
	de l'outil 
	<ulink url="http://www.phpwizard.net/projects/phpMyAdmin/">phpMyAdmin
	</ulink>.
	Celui-ci permet de créer la base de donnée et de l'administrer à travers
	une interface web (elle même écrite en PHP d'ailleurs).
	Par conséquent, une administration à distance ide la base devient
	aussi simple que si on avait accès au poste où se trouve la base.
	<figure id="phpmyadmin-fig">
	<title>L'interface d'administration phpMyAdmin</title>
	<screenshot>
	<screeninfo>L'interface d'administration phpMyAdmin</screeninfo>
	<graphic format="JPG" fileref="phpmyadmin.jpg"/>
	</screenshot>
	</figure>

</para>    
</sect1>
</chapter> 

<!-- Chapitre  -->
<chapter>
<title>Accéder à une base MySQL avec PHP</title>

<para>
Examinons maintenant comment il est possible d'exploiter ces logiciels
pour fournir aux visiteurs, à la fois un affichage des produits présents
dans notre base de données, et un moyen pour le visiteur d'ajouter un nouveau
produit à cette base. Nous commençons avec un programme PHP qui doit nous 
permettre de générer une page HTML, sur laquelle figure un tableau des
produits avec leurs prix correspondants. Nous mettrons ce code dans le
fichier <filename>lecture.php</filename>.
</para>

<!-- Affichage  -->
<sect1>
<title>Conseils pour le diagnostic d'erreur</title>
<!-- Affichage  -->
<para>
Du fait des langages multiples utilisés, il est parfois difficile
d'identifier simplement la source d'un dysfonctionnement lors du développement des programmes.
</para>
<para>
Il est donc conseillé de manière générale, de ne pas faire l'économie des
tests d'erreurs. Par exemple, la tentative de connexion à une base devrait
prévoir l'échec de la connexion :
<programlisting>
@mysql_connect("$hostname", "$username", "$password")
      or die("Impossible de se connecter a la base");
</programlisting>
</para>

<para>
De même, pour toutes les requêtes MySQL, je conseille de définir une
fonction comme celle-ci :
<programlisting>
function teste_erreur($query) {
    $error = mysql_errno();
    $error_msg = mysql_error();
    if (!empty($error_msg)) {
        echo "L'erreur $error_msg s'est produite (code=$error)";
        echo "pour la requête $query\n";
    }
}
</programlisting>
et de l'appeler systématiquement après une requête <command>mysql_query($q)</command> de façon à ne pas chercher trop longtemps la cause de l'erreur :

<programlisting>
   $q = " ..... "
   mysql_query($q);
   teste_erreur($q);
</programlisting>
</para>
</sect1>
<sect1>
<title>Lecture et affichage HTML des données</title>

<sect2 id="lecture">
<title>Lecture des données</title>
<para>
Supposons que nous ayons une base de données appelée 
<varname>base</varname> comportant une table appelée 
<varname>produit</varname>. 
Notre première tâche est de demander à PHP de se connecter
à l'ordinateur sur lequel se trouve la base MySQL, puis
de préciser qu'on veut utiliser cette table :
</para>

<programlisting>
&lt;?
mysql_connect("localhost","root","") or die("Impossible de se connecter");;
mysql_select_db("base") or die("pas possible de trouver la base");
</programlisting>

<para>
Ici, nous spécifions que la base est sur l'ordinateur qui exécute le
script PHP (<varname>localhost</varname>), et qu'on se connecte
en tant qu'administrateur de la base (<varname>root</varname>), qui
n'a pas de mot de passe.
<note>
<para>
Si votre base MySQL à été paramétrée différement, changez bien sûr les
paramètres (vérifier entre autres que vous n'avez pas besoin d'un mot
de passe).
</para>
</note>

L'instruction <function>die</function> permet d'arrêter le script avec un message d'erreur
en cas d'échec.
</para>

<para>
Demandons maintenant de lister toutes les informations de notre 
table <varname>produit</varname>. Il faut d'abord, à travers
PHP, faire une requête SQL qui permette de selectionner tous les
champs de la table (première ligne).

<programlisting>
$result = mysql_query("SELECT * FROM produit");
$nblignes = mysql_num_rows($result);
</programlisting>

Le résultat de cette requête est un tableau de données, comme les
deux dernières lignes du tableau suivant :
<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>ref</entry><entry>nom</entry><entry>prix</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>canon bj10e</entry><entry>120</entry>
</row>
<row>
<entry>2</entry><entry>epson stylus 8c</entry><entry>135</entry>
</row>
</tbody>
</tgroup>
</informaltable> 

Nous devons traiter les lignes du tableau les unes après les
autres. Pour cela, nous avons besoin de connaître le nombre
de ligne de notre tableau. C'est ce qui est fait à la deuxième ligne
de l'extrait de code précédent, et le résultat est conservé dans <varname>nblignes</varname>.
Nous sommes maintenant prêt à afficher nos données présentes dans 
<varname>result</varname>, dans le format HTML.
</para>
</sect2>

<sect2>
<title>Afficher les données</title>
<para>
Nous voulons présenter nos données sous la forme d'une table HTML.
Il faut donc faire écrire à PHP, le code HTML correspondant.
</para>
<para>
La première ligne de la table est constante : il s'agit de l'entête.
Ensuite, il faut extraire, pour chaque ligne de notre tableau,
les valeurs à afficher. Pour cela, nous extrayons pour chaque ligne 
<varname>i</varname> les valeurs des champs nom et prix de notre table,
avec la commande <command>mysql_result()</command>. 
Celle-ci prend en argument la table, le numéro de ligne, et le nom de colonne
pour rendre la valeur correspondante dans la table.
Nous mettons les valeurs nom et prix de la table respectivement dans les variables 
PHP <varname>$prod_nom</varname> et <varname>$prod_prix</varname> 
(le nom de ces variables PHP est tout à fait 
arbitraire et n'a pas de relation avec le nom des colonnes SQL).
Quand les valeurs de la ligne ont
été récupérées, nous pouvons écrire la ligne correspondante du tableau HTML. 
Enfin, nous fermons la table quand toutes les lignes ont été examinées.

<programlisting>
<![CDATA[ 
    echo "<table><tr><td> Désignation </td><td> Prix </td></tr>\n";
    for ($i=0;$i<$nblignes;$i=$i+1) {
	 $prod_nom =  mysql_result($result,$i,"nom");
	 $prod_prix = mysql_result($result,$i,"prix");
	 echo "<tr><td>$prod_nom</td><td>$prod_prix</td></tr>";
    }
    echo "</table>";
]]>
</programlisting>

</para>
<para>
Enfin, il nous faut par prudence refermer la base MySQL mais la quasi-totalité
du code PHP nécessaire à la consultation de notre table est écrit.
</para>
</sect2>

<sect2>
<title>Une autre façon de faire ...</title>

<para>
Nous avons utilisé dans la solution précédente une boucle pour 
passer en revue chaque ligne de la table de résultat obtenue par la 
requête SELECT. Le nombre de lignes de la table est donné par
<command>mysql_numrows()</command> et chaque élément est extrait 
avec <command>mysql_result()</command>.
</para>
<para>
Une alternative un peu plus concise consiste à utiliser 
<command>mysql_fetch_array()</command>.
Cette fonction prend en argument la table de résultat obtenue par la requête
(<varname>$result</varname> dans notre exemple), et
renvoie un tableau associatif correspondant à une ligne de la table.
L'indexation du tableau est faite avec les noms des colonnes de la table SQL.
Par exemple, si on récupère un tableau <varname>$t</varname> 
($t = mysql_fetch_array($result)),
et qu'un des champs SQL a pour nom <varname>id</varname>, alors on peut 
accéder à la valeur de la ligne lue par <varname>$t['id']</varname>.
La fonction gère un poineur interne: lors du premier appel, ce sont les éléments
de la première ligne qui sont mis en tableau. Chaque nouvel appel fait progresser 
le pointeur pour permettre de lire la ligne suivante.
</para>
<para>
Un équivalent au bout de code précédent est:
<programlisting>
<![CDATA[ 
      echo "<table><tr><td> Désignation </td><td> Prix </td></tr>\n";
      while ($ligne = mysql_fetch_array($result)) {
   		echo "<tr><td> $ligne['nom'] </td><td>$ligne['prix']</td></tr>";
      }
      echo "</table>";
]]>
</programlisting>
</para>
</sect2>

<sect2>
<title>Programme complet</title>

<para>
Récapitulons en listant maintenant le programme complet qui permet 
de lire le contenu
de notre table. Donnez une extension php à votre nom de fichier 
(<filename>lecture.php</filename> par exemple).

<programlisting>
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt; Catalogue produit&lt;/h1&gt;
&lt;?
mysql_connect("localhost","root","") or die("Impossible de se connecter");;
mysql_select_db("base") or die("pas possible de trouver la base");

$result = mysql_query("SELECT * FROM produit");
$nblignes = mysql_numrows($result);
    
echo "&lt;table&gt;&lt;tr&gt;&lt;td&gt;Désignation&lt;/td&gt;&lt;td&gt;Prix&lt;/td&gt;&lt;/tr&gt;\n";
for ($i=0;$i&lt;$nblignes;$i=$i+1) {
	 $prod_nom =  mysql_result($result,$i,"nom");
	 $prod_prix = mysql_result($result,$i,"prix");
	 echo "&lt;tr&gt;&lt;td&gt;$prod_nom&lt;/td&gt;&lt;td&gt;$prod_prix&lt;/td&gt;&lt;/tr&gt;";
}
echo "&lt;/table&gt;";
mysql_close();
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</programlisting>
</para>
</sect2>
</sect1>
<!-- Ecriture  -->
<sect1>
<title>Insertion de données dans la base</title>

<para>
Pour la mise à jour de la base nous avons besoin de deux fichiers :
un premier fichier qui doit contenr un formulaire HTML dans lequel l'internaute
peut saisir les données à insérer dans la base, et un deuxième fichier
(PHP) qui permette de récupérer les données du formulaire pour les insérer dans
la base.
</para>
<sect2>
<title>Saisie des données (formulaire)</title>

<para>
Ici, le fichier peut être un simple fichier HTML, puisque toutes les éléments de la page sont statiques.
Nous l'appelons <filename>saisie.html</filename>. 
Notez que la mise en page HTML est des
plus sommaires, ceci afin d'améliorer la lisibilité et se concentrer
sur les éléments importants du code.
<programlisting>
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;Mise à jour de la base&lt;/h1&gt;
&lt;form method="post" action="maj.php"&gt;
Référence : &lt;input type="text" name="ref"&gt;&lt;br&gt;
Nom       : &lt;input type="text" name="nom"&gt;&lt;br&gt;
Prix      : &lt;input type="text" name="prix"&gt;&lt;br&gt;
            &lt;input type=submit value="Insérer"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</programlisting>
</para>
<para>

Il est important de remarquer la partie <function>action</function>
du formulaire. C'est ici qu'on précise quel programme doit
récupérer les données du formulaire et les traiter.
Dans notre cas, il s'agit du fichier <filename>maj.php</filename>,
qui sera chargé lorsque le bouton de type <function>submit</function>
sera pressé.
</para>
<para>

Rappelons que toute cette section ne présente que des éléments connus
d'un programmeur HTML. Rien de nouveau !

</para>
</sect2>
<sect2>
<title>Récupération des valeurs du formulaire HTML en PHP</title>
<para>

Nous voulons mainteant récupérer les données du formulaires pour les insérer dans la base. 
Avant de l'écrire, il est d'abord nécessaire de savoir comment sont transmises
les données du formulaire à notre nouveau fichier (celui désigné par l'attribut <command>action</command>
dans le formulaire précédent), et comment on peut récupérer ces valeurs en PHP.
</para>
<para>
Techniquement, le formulaire HTML est <emphasis>posté</emphasis> lorsque l'utilisateur 
appuie sur le bouton de type <command>submit</command> et que la balise <command>form</command>
spécifie <command>method="post"</command>.
Ceci veut dire qu'une requête HTTP de type POST est émise vers le serveur, 
et cette requête contient les valeurs du formulaire. 
La forme sous laquelle sont transmises les valeurs est une suite de couples 
(<command>variable</command> = <command>valeur</command>).
</para>
<para>
PHP récupère ces valeurs postées dans un tableau qu'il nomme <command>$_POST</command>.
C'est un tableau associatif, dont les index de tableaux sont les noms des variables 
(voir le paragraphe sur les tableaux associatifs en PHP). 
Il est donc facile de retrouver la valeur associée à une variable.
Par exemple, <command>$_POST['prix']</command> désigne la valeur associée au champ HTML <varname>prix</varname> 
dans le formulaire posté.
</para>
<tip>
<para>
Dans les anciennes configurations de PHP (avant PHP 4.2.0), il n'était pas nécessaire de récupérer explicitement les variables postées. 
PHP créait automatiquemlent des variables PHP de même nom que les champs déclarés dans le forumaire HTML. 
Ainsi, on récupère la valeur du champ <command>&lt;input type="text" name="prix"&gt;</command> du formulaire dans une variable <command>$prix</command>.
Ce mode aujourd'hui désactivé pour des raisons de sécurité, peut être rétabli
en écrivant <command> register_globals = On </command> dans le fichier <filename>php.ini</filename>.
</para>
</tip>
</sect2>
<sect2>
<title>Ecriture des données</title>
<para>
	  Maintenant que nous savons récupérer les valeurs des variables du formulaire, il faut les sauvegarder dans la base de données.
</para>
<para>
Nous écrivons un deuxième fichier, que nous appelons <filename>maj.php</filename>.
Voyons le listing de notre fichier. 
On retrouve les instructions de connexion à la base, comme dans
<xref linkend="lecture"/>. 
Sur le principe, seule la requête SQL change, avec un 
<function>insert</function> au lieu d'un <function>select</function>.

<programlisting>
&lt;html&gt;
&lt;body&gt;
&lt;?
// connexion à la base
mysql_connect("localhost","root","") or die ("Impossible de se connecter");
mysql_select_db("base") or die("Impossible de trouver la base");           

// recuperation des valeurs du formulaire
$nom = $_POST['nom'];
$prix= $_POST['prix'];

// insertion des valeurs dans la base
$query = "insert into produit (nom,prix) values ('$nom','$prix')";
$result=mysql_query($query);
mysql_close();
?&gt;
Mise a jour faite
&lt;/body&gt;
&lt;/html&gt;
</programlisting>

Ici, on suppose toujours que <varname>ref</varname> est une clé primaire
de la table produit, et qu'elle possède en plus la propriété <command>
autoincrement</command>. 
Ainsi, nous n'avons pas à gérer l'unicité de la référence, puisque MySQL
inserera automatiquement une référence entière supérieure aux autres références
trouvées.

</para>
</sect2>
<sect2>
<title> Modification de données</title>
<para>
La modification de données (on dit encore la mise a jour, ou le remplacement de valeur)
peut porter sur une ou plusieurs lignes, d'une ou plusieurs tables.
La modification est introduite par la requête SQL :
<programlisting>
    replace into table 
           (champ1,champ2,...) 
    where  (conditions)
    values (val1,val2,...);
</programlisting>
qui remplace les valeurs présentes dans champ1 par val1, champ2 par val2, etc.
</para>
<para> 
Commençons par le cas simple : modifier les valeurs d'une seule ligne.
On veut par exemple modifier le prix d'un article de notre exemple précédent.
On utilise ici la clé primaire <varname>ref</varname>, unique qui a pour conséquence que
le remplacement ne se fait que sur une ligne.
<programlisting>
$query = "replace into produit (ref,prix) values ('$ref','$nouveau_prix')";
echo "Le prix de l'article $ref est modifié .."; 
</programlisting>

</para>
</sect2>
</sect1>

<!-- ___________ Gerer plusieurs tables _____________ -->
<sect1>
<title>Gérer plusieurs tables</title>

<para>
Nous n'avons jusqu'ici considéré que la base de données n'était constituée
que d'une table. 
Dans la réalité, la base de données est toujours constituée de plusieurs tables,
et il est donc naturel d'aller chercher, pour un élément d'une table, des
informations liées présentes dans d'autres tables.
</para>
<para>
Faire une sélection impliquant plusieurs tables implique un mécanisme plus 
difficile à comprendre. La sélection revient à faire le 
<emphasis>produit cartésien</emphasis> des tables. 
Une bonne compréhension de ces mécanismes peut être acquise dans des ouvrages
traitant spécifiquement des bases de données relationnelles et de SQL.
Cependant, l'exemple simple suivant permet de schématiser ce processus.
</para>

<sect2>
<title>L'exemple simple d'un forum</title>

<para>
Dans un forum de discussions, on pourrait avoir par exemple les deux tables
suivantes: une table recensant les messages postés avec pour chaque message,
le numéro d'utilisateur l'ayant posté. Dans une table profils, on retrouverait
toutes les informations sur cet utilisateur.
<programlisting>
posts    (numpost,user,texte)    
profils  (user,pseudo,email)
</programlisting>
Un exemple simplifié de données pour de telles tables pourrait être:
<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>numpost</entry><entry>user</entry><entry>texte</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>1</entry><entry>Hello, does anybody knows what is SQL?</entry>
</row>
<row>
<entry>2</entry><entry>1</entry><entry>Hello again, anyone listening?</entry>
</row>
<row>
<entry>3</entry><entry>2</entry><entry>Hello, you'd better buy a book and read it.</entry>
</row>
</tbody>
</tgroup>
</informaltable> 
et
<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>user</entry><entry>pseudo</entry><entry>email</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>newbie555</entry><entry>newbie@hotmail.com</entry>
</row>
<row>
<entry>2</entry><entry>jobasher</entry><entry>jo.basher@gmail.com</entry>
</row>
</tbody>
</tgroup>
</informaltable> 
</para>

<para>
Pour l'affichage des messages, on veut bien sûr pouvoir associer au message 
le pseudo ou l'email de l'utilisateur ayant posté le message, ce qui demande
d'aller trouver, à partir de <varname>numpost</varname> le <varname>pseudo</varname>
correspondant. Par exemple, le post 3 (<varname>numpost=3</varname>) à été
posté par un utilisateur de pseudo jobasher.
</para>

<para>
On peut illustrer sur cet exemple simple, la requête SQL qui va nous permettre
d'obtenir le résultat. Etant donné un numéro de post (disons 3), on veut le pseudo 
associé tiré de la table <varname>profils</varname>:
<programlisting>
select pseudo
  from posts,profils
where
   numpost = 3 and 
   posts.user = profils.user
</programlisting>
</para>

<tip>
<para>
   En SQL, un même nom de champ (de colonne) peut être utilisé dans plusieurs
   tables. Il devient donc ambigu quand ces tables sont utilisées en même temps.
   Pour lever l'ambiguité, il suffit de préfixer le nom du champ
   par le nom de sa table. Ici par exemple, on
   écrit <varname>profils.user</varname> pour préciser de quel
   champ <varname>user</varname> il s'agit.
</para>
</tip>

<para>
Dire qu'on sélectionne deux tables provoque le produit cartésien des deux tables.

<informaltable>
<tgroup cols="6">
<thead>
<row>
<entry>numpost</entry><entry>user</entry><entry>texte</entry>
<entry>user</entry><entry>pseudo</entry><entry>email</entry>
</row>
</thead>
<tbody>
<row>
<entry>1</entry><entry>1</entry><entry>Hello, does anybody knows what is SQL?</entry>
<entry>1</entry><entry>newbie555</entry><entry>newbie@hotmail.com</entry>
</row>
<row>
<entry>1</entry><entry>1</entry><entry>Hello, does anybody knows what is SQL?</entry>
<entry>2</entry><entry>jobasher</entry><entry>jo.basher@gmail.com</entry>
</row>
<row>
<entry>2</entry><entry>1</entry><entry>Hello again, anyone listening?</entry>
<entry>1</entry><entry>newbie555</entry><entry>newbie@hotmail.com</entry>
</row>
<row>
<entry>2</entry><entry>1</entry><entry>Hello again, anyone listening?</entry>
<entry>2</entry><entry>jobasher</entry><entry>jo.basher@gmail.com</entry>
</row>
<row>
<entry>3</entry><entry>2</entry><entry>Hello, you'd better buy a book and read it.</entry>
<entry>1</entry><entry>newbie555</entry><entry>newbie@hotmail.com</entry>
</row>
<row>
<entry>3</entry><entry>2</entry><entry>Hello, you'd better buy a book and read it.</entry>
<entry>2</entry><entry>jobasher</entry><entry>jo.basher@gmail.com</entry>
</row>
</tbody>
</tgroup>
</informaltable> 

On constate aisément que dans ce produit cartésien (développant toutes les combinaisons
de colonnes des deux tables) la seule ligne qui satisfait aux contraintes de notre 
requête est la dernière du tableau: 
<varname>numpost=3</varname> et <varname>post.user</varname> ainsi que 
<varname>profils.user</varname> sont égaux (2).
Le résultat à notre requête est donc la table:
<informaltable>
<tgroup cols="1">
<thead>
<row>
<entry>pseudo</entry>
</row>
</thead>
<tbody>
<row>
<entry>jobasher</entry>
</row>
</tbody>
</tgroup>
</informaltable> 


</para>
</sect2>


<sect2>
<title>Exemple avec trois tables</title>
<para>
Prenons maintenant un autre exemple.
Imaginons que notre base est faite de trois tables : 
les tables clients, produits et commandes.
<programlisting>
clients (clid,nom)                          clé : clid
produits(pid,descr,prix)                    clé : pid
commandes(pid,clid,quantite,montant,date)   clé : pid,clid
</programlisting>
</para>


<para>
Pour lister les clients qui ont passé des commandes de plus de 2000 Euros
et afficher ce qu'ils ont commandé, on peut écrire la requête SQL
suivante :
<programlisting>
select client.nom,produits.descr 
  from produits,commandes,clients
where
   commandes.montant >  2000  and
   commandes.pid=produits.pid and
   commandes.clid=clients.clid
</programlisting>
</para>
<para>
Pour se persuader que la commande <command>select</command> précédente remplit 
bien notre objectif, paraphrasons la. 
Nous obtiendrons au final une table composée des colonnes
<varname>client.nom</varname> et <varname>produits.descr</varname>.
Dans la table <varname>commandes</varname> seules les lignes dont le
montant dépassent 2000 sont sélectionnées. A chacune de ces lignes
correspond un numéro de client <varname>(commandes.clid)</varname>.
Ne seront sélectionnées dans les autres tables que les lignes dont le 
numéro de client est égal à celui-ci. 
</para>
</sect2>

</sect1>
</chapter>

</book>
