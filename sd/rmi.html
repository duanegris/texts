<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" /> 
<title>Introduction Ã  RMI</title>
<!-- metadata -->
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="presdate" content="20050128" />
<meta name="author" content="S. Genaud" />
<meta name="company" content="UniversitÃ© de Strasbourg" />

<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 525px; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 270px; height: 320px; position: relative; margin-top: 0.5em;}
#anim img {position: absolute; top: 42px; left: 24px;}
img#me01 {top: 0; left: 0;}
img#me02 {left: 23px;}
img#me04 {top: 44px;}
img#me05 {top: 43px;left: 36px;}

<style type="text/css">
body { font-size: 80%;}

.important { color : red; }

table.list { border-spacing : 3px; 
             margin-left: auto; 
             margin-right : auto; /* pour centrer la table */ 
           }
tr.list    { background-color : #eee59a; font : fixed; }
th.list    { background-color : #c2ddeb; }
td.list    { background-color : #eee59a; margin : 3px; 
        font-family : courier ; font-size : 11pt;}


#listing pre { padding: 0; margin: 0; 
               background-color : #c2ddeb; 
               font-size : 50%;
           border-bottom: 1px solid #000;
           border-top   : 1px solid #000;
           width: 100%; position: relative;}
</style>


<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>octobre &#8226; 2009</h1>
<h2>Introduction Ã  RMI</h2>
</div>
</div>

<div class="presentation">

<div class="slide">
<h1>Introduction Ã  RMI</h1>
<h4><a href="http://icps.u-strasbg.fr/~genaud">StÃ©phane Genaud</a></h4>
</div>

<!-- ________________________ GÃ©nÃ©ral _____________________________ -->
<div class="slide">
<h1>CaractÃ©ristiques gÃ©nÃ©rales</h1>
<ul>
   <li>RMI est un moyen de faire du client/serveur.
        <ul>
        <li> Limitation : tout les programmes sont en Java (sauf utilisation JNI).</li>
        <li> Permet d'invoquer des mÃ©thodes d'un objet distant dans une JVM distante.</li>
        </ul>
    </li> 
    <li>On peut passer des objets en paramÃ¨tre des appels distants.
        (Implique qu'on peut tÃ©lÃ©charger du code dans une JVM distante).
    </li>
    <li>
    AccessibilitÃ© : disponible dans tout JDK (&gt;=1.1) 
    </li>
</ul>  
</div>

<div class="handout">
<p>
JNI (Java Native Interface) doit permettre Ã  du code Java de s'interfacer avec d'autres langages (cibles principales le C/C++) mais son emploi semble dÃ©licat et peu convaincant.
</p>
<p>
Passer des objets est un mÃ©canisme plus puissant que les RPC habituels qui sont limitÃ©s Ã  des types primitifs (ou structures de type primitifs, e.g. CORBA).
</p>
</div>

<!-- ________________________ Objet proxy _____________________________ -->
<div class="slide">
<h1>Appel de procÃ©dure Ã  distance</h1>

<img src="img/proxy.png" alt="proxy" title="Principe de l'objet proxy">

<p>
L'objet distant possÃ¨de un <strong>reprÃ©sentant (proxy)</strong> sur la machine locale;
ceci permet d'invoquer une mÃ©thode de l'objet B comme si celui-ci Ã©tait local.
C'est la <strong>souche (stub)</strong> qui matÃ©rialise ce reprÃ©sentant.
</p>
<p>
Avant la version 5 du JDK, les souches sont des fichiers <tt>stub.class</tt>gÃ©nÃ©rÃ©s avec <tt>rmic</tt>. 
</p>
</div>

<div class="slide">
	  <h1>Les souches (stubs)</h1>
	  Quand le client appelle la m&eacute;thode souche dans la JVM locale, la souche :
	  <p>
	  <ul><li>
		   initie la connexion avec la JVM distante contenant l'objet,
		 </li>
		 <li>
		 op&egrave;re le marshalling (&eacute;criture et transmission) des param&egrave;tres Ã  la JVM distante,
		 </li>
		  <li>
		  attend les resultats de la m&eacute;thode invoqu&eacute;e,
		    </li>
		    <li>
		    opÃ¨re le demarshalling (lecture) de la valeur ou de l'exception retourn&eacute;e
		    et renvoie le r&eacute;sultat Ã  l'appelant. 
		    </li>
           </ul>
	     </p>
</div>
	  
<!-- ________________________ Exemple Hello World _____________________________ -->
<div class="slide">
<h1>Exemple 1</h1>

<p>
Exemple Simple: 
les arguments de la mÃ©thode invoquÃ©e sont des types primitifs (scalaires, e.g. int, float, ..) 
ou tableaux (e.g. String) mais <span class="important">sÃ©rialisables</a> (java.io.Serializable).  
</p>

<h2>Les diffÃ©rents programmes</h2>
<ul>
   <li>Le service : le code lui-mÃªme ; rÃ©pond aux clients. </li>
   <li>Le serveur : gÃ¨re le service. </li>
   <li>Le client : utilise le service.</li>
</ul>  
</div>


<!-- ________________________ Service _____________________________ -->
<div class="slide">
<h1>Le service</h1>

Le service est ici un objet dont l'une des mÃ©thodes fait l'addition de deux nombres.
  <ul>
     <li><tt>Operation.java</tt>     : interface utilisÃ©e par le client</li>
     <li><tt>OperationImpl.java</tt> : classe implÃ©mentant <tt>Operation</tt>, 
                                       lancÃ©e par le serveur</li>
  </ul>

</div>

<div class="slide">
<h1>L'interface du service</h1>

<tt>Operation.java</tt><br/>

<div id="listing">
<pre>
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface Operation extends Remote {

    public int addition(int a, int b) throws RemoteException ;

}
</pre>
</div>
<div class="handout">
<p>
<b>Remarque 1.</b>
En Ã©tendant l'interface java.rmi.Remote, les mÃ©thodes de l'interface sont automatiquement
appelables depuis d'autres JVM. 
Tout objet qui implÃ©mentera cette interface deviendra "remote".
</p>
<p>
<b>Remarque 2.</b> 
On pourrait bien sÃ»r dÃ©finir d'autres methodes Ã  cÃ´tÃ© de <tt>addition</tt>. 
</p>

</div>
</div>
</div>


<div class="slide">
<h1>L'implÃ©mentation du service</h1>
<tt>OperationImpl.java</tt><br/>
<div id="listing">
<pre>
import java.rmi.server.UnicastRemoteObject ;
import java.rmi.RemoteException ;
import java.net.InetAddress.* ;
import java.net.* ;

public class OperationImpl extends UnicastRemoteObject
  implements Operation  {

    public OperationImpl () throws RemoteException {
        super();
    };

    public int addition(int a, int b) throws RemoteException {
      return( a + b) ;
  }
}
</pre>
</div>
<!-- _________________________ Remarques ________________________ -->
<div class="handout">
<p>
Le service hÃ©rite de la classe <tt>java.rmi.UnicastRemoteObject</tt> pour activer l'objet distribuÃ© automatiquement.
</p>
<p><b>Remarque.</b> On pourrait dÃ©finir directement l'enregistrement
de l'objet en ajoutant, par exemple dans main :
<div id="listing">
<pre>
   public static void main(String args[]) {
     try {
         OperationImpl une_op = new OperationImpl ();
         Naming.rebind("rmi://localhost/Operation",une_op) ;
         System.out.println("Service Operation enregistrÃ©");
      }  
      catch(Exception e) {
         System.out.println("Err. enreg. registry");
      }
    }
</pre>
</div>
Cependant, on prÃ©fÃ¨re isoler ce code assez gÃ©nÃ©rique dans un programme <tt>serveur</tt>.
</div>

</div>

<!-- ________________________ Serveur _____________________________ -->
<div class="slide">
<h1>Le serveur</h1>

<tt>Serveur.java</tt> est une classe qui
    <ol>
     <li>crÃ©e une instance de l'objet demandÃ© (le service),</li>
     <li>enregistre ce service dans le <tt>rmiregistry</tt> pour le rendre public. 
     Deux classes permettent de le faire (choisir une seule des 2 solutions):
     <ul style="font-size: smaller">
		     <li>La classe <tt>java.rmi.Naming</tt> avec 
		     m&eacute;thode <tt>bind()</tt> permet d'utiliser des URLs. </li>
           <li>La classe <tt>java.rmi.registry.LocateRegistry</tt> 
	     et sa m&eacute;thode <tt>getRegistry()</tt> est un niveau plus bas 
	     (elle est utilisÃ©e par <tt>Naming</tt>).
	     Cette classe permet de crÃ©er dynamiquement un registry (avec <tt>createRegistry()</tt>).</li>
         </ul>
    </li>
     <li>lance un gestionnaire de s&eacute;curit&eacute;.</li>
    </ol>
<i><small>Dans un premier temps, nous simplifions le code en ne crÃ©ant pas le gestionnaire de sÃ©curitÃ©.</small></i>
</div>

<div class="handout">
Le code du serveur est trÃ¨s gÃ©nÃ©rique : on rÃ©utilisera presque toujours la mÃªme chose pour dÃ©marrer des services.
</div>

<!-- _______ Code Serveur avec LocateRegistry _________ -->
<div class="slide">
 <h1>Le serveur</h1>

En utilisant la classe <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/registry/LocateRegistry.html"><tt>java.rmi.registry.LocateRegistry</tt></a> :

<div id="listing">
<pre width="80"><font color="#228B22">import java.rmi.registry.Registry;</font>
<font color="#228B22">import java.rmi.registry.LocateRegistry;</font>
<font color="#228B22">import java.rmi.RemoteException;</font>
<font color="#228B22">import java.rmi.server.UnicastRemoteObject;</font>

<strong><font color="#4169E1"><a name="Serveur"></a>public class Serveur </font></strong>{

<strong><font color="#4169E1">      public static void main( String [] args)</font></strong> {

      <font color="#4169E1">try</font> {
	   OperationImpl une_op = new OperationImpl ();

	   Registry registry = LocateRegistry.getRegistry();

	   registry.bind(<font color="#666666">"Operation"</font>,une_op); 
	   System.out.println(<font color="#666666">"Serveur pret"</font>); 
       }
       <font color="#4169E1">catch</font> (Exception e) { System.out.println(e) ; }
       }
}
</pre>
<div>

<!-- <div id="listing">
<pre>
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class Serveur {

      public static void main( String [] args) {

      try {
	   OperationImpl une_op = new OperationImpl ();

	   Registry registry = LocateRegistry.getRegistry();

	   registry.bind("Operation",une_op); 
	   System.out.println("Serveur pret"); 
       }
       catch (Exception e) { System.out.println(e) ; }
       }
}
</pre>
</div>
-->
<p>
<small>
 Il y a possibilitÃ© de crÃ©er le registry dynamiquement (au lieu de lancer 
rmiregistry sur la ligne de commande) avec 
<pre>
           Registry registry = LocateRegistry.createRegistry(1099);
</pre>
</small>
</p>

</div>

<!-- Commentaires -->
<div class="handout">
<p>
<tt>LocateRegistry.getRegistry()</tt> instancie une souche qui implÃ©mente l'interface Remote <tt>java.rmi.registry.Registry</tt> en demandant le registre sur localhost et le port 1099 (dÃ©fauts). Utiliser 
<tt> getRegistry(String, int)</tt> pour spÃ©cifier hÃ´te et port.

<tt>bind()</tt> est ensuite invoquÃ©e sur le stub pour que le registre attache le code de <tt>une_op</tt> au nom arbitraire "Operation".
</p>
<p>
Exemples :
<pre>
 Registry registry = LocateRegistry.getRegistry("foo.services.com");
 SomeService service = (SomeService)registry.lookup("toto");
 service.requestService(...);
</pre>
</p>
</div>


<!-- _______ Code Serveur avec Naming _________ -->
<div class="slide">
 <h1>Le serveur</h1>

 En utilisant la classe <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/Naming.html"><tt>java.rmi.Naming</tt></a> :
<div id="listing">
<pre>
import java.rmi.*;
import java.net.*;

public class Serveur {
   public static void main(String [] args) {
  
       try {
         OperationImpl une_op = new OperationImpl ();
         Naming.rebind("rmi://localhost/Operation",une_op) ;
         System.out.println("Serveur pret");
       }
	 catch (RemoteException re) { System.out.println(re) ; }
       catch (MalformedURLException e) { System.out.println(e) ; }
  }
}
</pre>
</div>
Pour des raisons de s&eacute;curit&eacute; les op&eacute;rations bind, rebind ou unbind
se font toujours avec un registry local.
</div>

<!-- Commentaires -->
<div class="handout">

<ul>
    <li>L'enregistrement passe par une connexion de type socket sur localhost</li>
    <li>Pour des raisons de s&eacute;curit&eacute; les op&eacute;rations bind, rebind ou unbind
	  se font toujours avec un registry local (tournant sur localhost).</li>
</ul>

</div>

<!-- _______ Gestionnaire de sÃ©curitÃ© _________ -->
<div class="slide">
<h1>Gestionnaire de sÃ©curitÃ© serveur</h1>

<ul>
  <li>DÃ©finie par le fichier <tt>java.policy</tt></li>
  <li>Par dÃ©faut, celui du JDK, e.g. <br/>
    <tt>/usr/java/j2sdk1.4.2_04/jre/lib/security/java.policy</tt>
  </li>
  <li> Donner plus de permissivitÃ© :<br/>
    <div id="listing">
    <pre>
    grant {
      permission java.net.SocketPermission 
           "*:80-65535","connect,accept,listen,resolve";
      permission java.security.AllPermission;
    };
   </pre>
   </div>
  </li>
</ul>
</div>


<!-- ________________________ Le client  _____________________________ -->
<div class="slide">
<h1>Le client</h1>

<p>
<tt>Client.java</tt> : le code utilisant l'interface <tt>Operation</tt>.
</p>

<p>
Avant d'invoquer une m&eacute;thode de l'interface, il faut obtenir une rÃ©fÃ©rence.
Comme pour le serveur, deux classes permettent de le faire :
<ul>
    <li>Avec la classe de plus haut niveau <tt>java.rmi.Naming</tt> : 
    m&eacute;thode <tt>lookup()</tt> </li>
   <li>Avec la classe de bas niveau <tt>java.rmi.Registry</tt> 
   et sa m&eacute;thode <tt>lookup()</tt>.
   </li>
</ul>
 
</div>

<div class="slide">
<h1>Le client</h1>
En utilisant la classe <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/Naming.html"><tt>java.rmi.Naming</tt></a> :
<div id="listing">
<pre width="80">
<font color="#228B22">import java.rmi.* ;</font>
<font color="#228B22">import java.net.MalformedURLException ;</font>
<font color="#228B22">import java.io.*;</font>

<strong><font color="#4169E1"><a name="Client"></a>public class Client </font></strong>{
<strong><font color="#4169E1">  public static void main(String [] args)</font></strong> {
    <font color="#4169E1">if</font> (args.length != 1)
        System.out.println(<font color="#666666">"Usage : java Client Serveur"</font>);
    <font color="#4169E1">else</font> {
        <font color="#4169E1">try</font> {
          Operation o =
             (Operation) Naming.lookup(<font color="#666666">"//"</font>+args[0]+<font color="#666666">"/Operation"</font>);
          System.out.println(<font color="#666666">"Client : 33 + 45 = ? "</font>);
          int r = o.addition( 33 , 45 );
          System.out.println(<font color="#666666">"Le serveur a calcule : 33+45="</font>+ r );
        }
        <font color="#4169E1">catch</font> (NotBoundException re) { System.out.println(re) ; }
        <font color="#4169E1">catch</font> (RemoteException re) { System.out.println(re) ; }
        <font color="#4169E1">catch</font> (MalformedURLException e) { System.out.println(e) ; }
     }
   }
}
</pre>

<!--<pre>
import java.rmi.* ;
import java.net.MalformedURLException ;
import java.io.*;

public class Client {
  public static void main(String [] args) {
    if (args.length != 1)
        System.out.println("Usage : java Client Serveur");
    else {
        try {
	    Operation o =
             (Operation) Naming.lookup("//"+args[0]+"/Operation");
          System.out.println("Client : 33 + 45 = ? ");
          int r = o.addition( 33 , 45 );
          System.out.println("Le serveur a calcule : 33+45="+ r );
        }
        catch (NotBoundException re) { System.out.println(re) ; }
        catch (RemoteException re) { System.out.println(re) ; }
        catch (MalformedURLException e) { System.out.println(e) ; }
     }
   }
}
</pre>-->
</div>
</div>
<!-- ________________________ Compilation _____________________________ -->
<div class="slide">
<h1>Compilation</h1>
<div id="listing">
<pre>
javac *.java
rmic OperationImpl # inutile pour JVMs provenant de JDK &gt;= 5.0

mkdir serveur 
mkdir client

for i in Client OperationImpl_Stub Operation
do  cp $i.class client ; done

for i in Serveur OperationImpl_Stub OperationImpl_Skel\
         OperationImpl Operation
do  cp $i.class serveur ; done
</pre>
</div>

<!-- Commentaires -->
<div class="handout">
La commande <code>rmic OperationImpl</code> gÃ©nÃ¨re 
<tt>OperationImpl_Stub.class</tt> et <tt>OperationImpl_Skel.class</tt>.
</div>


<div class="slide">
<h1>Compilation : fichiers</h1>
<table class="list">
<tr><th class="list">client</th><th class="list">  serveur</th></tr>
<tr class="list"><td>Client.class       </td><td>  Serveur.class</td></tr>
<tr class="list"><td>Operation.class    </td><td>  OperationImpl.class</td></tr>
<tr class="list"><td>                   </td><td>  OperationImpl_Skel.class</td></tr>
<tr class="list"><td>OperationImpl_Stub.class</td><td>OperationImpl_Stub.class</td></tr>
</table>
</div>




<!-- ________________________ Execution _____________________________ -->

<div class="slide">
<h1>ExÃ©cution</h1>

<ol>
   <li> Lancer le serveur 
    <p>
    <div id="listing">
<pre>
     cd serveur 
     rmiregistry &amp;  
     java -Djava.security.policy=java.policy Serveur 
</pre></div></p>
</li>

   <li>Lancer le client
   <p>
    <div id="listing">
<pre>
    cd client
    java Client localhost
</pre></div></p>
    </li>
</ol>
</div>

<div class="handout">

<p>
Lancer "start rmiregistry" sous windows, ou monopoliser un terminal pour lui.
</p>
<p>
Lancer le rmiregistry dans le mÃªme rÃ©pertoire que le serveur (oÃ¹ se trouve OperationImpl_Stub.class)
est bien commode car le CLASSPATH contient le rÃ©pertoire courant par dÃ©faut. Si vous lancez rmiregistry ailleurs, il faut que le CLASSPATH pointe vers oÃ¹ se trouve OperationImpl_Stub.class.
</p>
</div>

<!-- __________ Exemple 2 : passage d'objets  ________________________ -->

<div class="slide">
<h1>Exemple 2: Passage d'objets</h1>

<p>
RMI permet de passer en paramÃ¨tres des mÃ©thodes, des types simples, mais
aussi des <span class="important">objets construits</span>.
</p>
<p>
Comme prÃ©cÃ©demment, les arguments passÃ©s doivent Ãªtre <strong>serializable</strong>.
</p>
<p>
La sÃ©rialisation Ã©crit la <span class="important">structure</span> de l'objet 
dans un flux transmissible sur le rÃ©seau, mais n'incorpore pas au flux les mÃ©thodes.
</p>

</div>
<!-- __________ Passage d'objets en parametre  ________________________ -->

<div class="slide">
<h1>Exemple 2: Passage d'objets en paramÃ¨tres</h1>

Imaginons un objet dont le rÃ´le est d'exÃ©cuter du code.
<table>
<tr>
<td>
<img src="img/object_parameter.png" alt="pass object" title="Passing objects">
</td>

<td>
<p>
<ul>
<li>Il accepte en entrÃ©e un objet quelconque qui a une mÃ©thode <tt>execute()</tt>
<small>(appelons <tt>Task</tt> l'interface correspondante)</small>, </li>
<li>tÃ©lÃ©charge dynamiquement le code de l'implÃ©mentation (cherche dans <tt>codebase</tt>),</li>
<li>invoque <tt>execute()</tt>,</li>
<li>retourne le rÃ©sultat au client.</li>
</ul>
</td>
</tr>
</table>
</div>


<!-- __________ Interfaces  ________________________ -->
<div class="slide">
<h1>Objet Remote Compute (interface)</h1>

<p>
Comme prÃ©cÃ©demment, on doit spÃ©cifier au client l'interface offerte par
l'objet distant. On la nomme <tt>Compute.java</tt>.
<div id="listing">
<pre> 
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface Compute extends Remote {
    Object executeTask(Task t) throws RemoteException;
}
</pre>
</div>
</p>
<p>
L'unique mÃ©thode accepte un objet de classe <tt>Task</tt>.
</p>
</div>

<!-- __________ Interfaces  ________________________ -->
<div class="slide">
<h1>Objet Remote Compute (impl.)</h1>
Sur le serveur, l'implÃ©mentation <tt>ComputeImpl.java</tt> :
<div id="listing">
<pre width="80">
<font color="#228B22">import java.rmi.server.UnicastRemoteObject ;</font>
<font color="#228B22">import java.rmi.RemoteException ;</font>
<font color="#228B22">import java.net.* ;</font>

<strong><font color="#4169E1"><a name="ComputeImpl"></a>public class ComputeImpl extends UnicastRemoteObject implements Compute</font></strong>
{
<strong><font color="#4169E1">    public ComputeImpl()</font></strong> <font color="#4169E1">throws</font> RemoteException {
       <font color="#B22222">/* constructeur de la classe mere UnicastRemoteObject */</font>
       super();   
    }
<strong><font color="#4169E1">    public Object executeTask(Task t)</font></strong> {
       <font color="#B22222">/* les objets passes en arg. doivent fournir une methode execute() */</font>
       <font color="#4169E1">return</font> t.execute();   
    }
}
</pre>

<!-- <pre> 
import java.rmi.server.UnicastRemoteObject ;
import java.rmi.RemoteException ;
import java.net.* ;

public class ComputeImpl extends UnicastRemoteObject implements Compute
{
    public ComputeImpl() throws RemoteException {
       /* constructeur de la classe mere UnicastRemoteObject */
       super();   
    }
    public Object executeTask(Task t) {
       /* les objets passes en arg. doivent fournir une methode execute() */
       return t.execute();   
    }
}
</pre>
-->

</div>

</div>


<!-- __________ Task interface ________________________ -->
<div class="slide">
<h1>La classtask passÃ© en paramÃ¨tre</h1>

<p>
L'interface <tt>Task.java</tt> : spÃ©cifie
<div id="listing">

<pre width="80">
<font color="#228B22">import <b class="important">java.io.Serializable</b>;</font>

public interface Task extends <b class="important">Serializable</b> {
    Object execute();
}
</pre>


<!-- <pre> 
import <b class="important">java.io.Serializable</b>;

public interface Task extends <b class="important">Serializable</b> {
    Object execute();
}
</pre>
-->
</div>
</div>


<!-- __________ Task impl. ________________________ -->
<div class="slide">
<h1>L'objet task passÃ© en paramÃ¨tre (impl)</h1>

<p>
L'implÃ©mentation <tt>TaskPi.java</tt>:
<div id="listing">

<pre width="80">
<strong><font color="#4169E1"><a name="TaskPi"></a>public class TaskPi implements Task </font></strong>{

<strong><font color="#4169E1">    public TaskPi(int digits)</font></strong> {  <font color="#B22222">//constructeur</font>
        this.digits = digits;
    }

    public Object <b class=important">execute()</b> {
        <font color="#4169E1">return</font> computePi(digits);
    }

<strong><font color="#4169E1">    public static BigDecimal computePi(int digits)</font></strong> {

        <font color="#B22222">/* ... calcul compliquÃ© ...*/</font>
        <font color="#4169E1">return</font> pi.setScale(digits,BigDecimal.ROUND_HALF_UP);
    }
}
</pre>


<!--<pre> 
public class TaskPi implements Task {

    public TaskPi(int digits) {  //constructeur
        this.digits = digits;
    }

    public Object <b class="important">execute()</b> {
        return computePi(digits);
    }

    public static BigDecimal computePi(int digits) {
        
        /* ... calcul compliquÃ© ...*/
        return pi.setScale(digits,BigDecimal.ROUND_HALF_UP);
    }
}
</pre> -->
</div>
</p>


</div>

<!-- __________ Task  ________________________ -->
<div class="slide">
<h1>Le client <tt>Client.java</tt></h1>

<div id="listing">

<pre width="80">
<font color="#228B22">import java.rmi.*;</font>
<font color="#228B22">import java.math.*;</font>

<font color="#B22222">/* Un code qui utilise l'objet remote Compute doit (1) obtenir une reference vers cet objet, (2) creer un objet Task, (3) appeler l'execution de la tache en passant la tache a Compute */</font>

<strong><font color="#4169E1"><a name="Client"></a>public class Client </font></strong>{
<strong><font color="#4169E1">    public static void main(String args[])</font></strong> {
        <font color="#4169E1">if</font> (System.getSecurityManager() == null) {
            System.setSecurityManager(new RMISecurityManager());
        }
        <font color="#4169E1">try</font> {
            String name = <font color="#666666">"rmi://"</font> + args[0] + <font color="#666666">"/Compute"</font>;
            <font color="#B22222">/* obtenir une ref. sur un objet Compute */</font>
            Compute engine = (Compute) Naming.lookup(name);
            <font color="#B22222">/* instancie un objet de calcul */</font>
            TaskPi ma_tache = new TaskPi(Integer.parseInt(args[1]));
            <font color="#B22222">/* faire calculer la tache envoyee et recuperer */</font>
            BigDecimal pi = (BigDecimal) (engine.executeTask(ma_tache));
            System.out.println(pi);
        } <font color="#4169E1">catch</font> (Exception e) {
            System.err.println(<font color="#666666">"Exception du client : "</font> + e.getMessage());
            e.printStackTrace();
        }
    }
}
</pre>

<!--
<pre> 
import java.rmi.*;
import java.math.*;

/* Un code qui utilise l'objet remote Compute doit 
   - obtenir une reference vers cet objet, 
   - creer un objet Task , 
   - appeler l'execution de la tache en passant la tache a Compute
*/

public class Client {
    public static void main(String args[]) {
        if (System.getSecurityManager() == null) {
            System.setSecurityManager(new RMISecurityManager());
        }
        try {
            String name = "rmi://" + args[0] + "/Compute";
            /* obtenir une ref. sur un objet Compute */
            Compute engine = (Compute) Naming.lookup(name); 
            /* instancie un objet de calcul */
            TaskPi ma_tache = new TaskPi(Integer.parseInt(args[1]));  
            /* faire calculer la tache envoyee et recuperer */
            BigDecimal pi = (BigDecimal) (engine.executeTask(ma_tache));   
            System.out.println(pi);
        } catch (Exception e) {
            System.err.println("Exception du client : " + e.getMessage());
            e.printStackTrace();
        }
    }
}
</pre>
-->
</div>

</div>

<!-- __________ Serveur  ________________________ -->
<div class="slide">
<h1>Le serveur <tt>Server.java</tt></h1>

<p>
<div id="listing">
<pre> 
import java.rmi.*;
import java.net.*;

public class Server {
  public static void main(String [] args) {
     if (System.getSecurityManager() == null) {
         System.setSecurityManager(new RMISecurityManager());
     }
     try {
         ComputeImpl <b class="important">engine1</b> = new ComputeImpl ();
         Naming.rebind("rmi://localhost/Compute",<b class="important">engine1</b>) ;
         System.out.println("Objet Compute enregistrÃ© dans le registry.");
         System.out.println("Serveur pret.");
     }
     catch (RemoteException re) { System.out.println(re) ; }
     catch (MalformedURLException e) { System.out.println(e) ; }
  }
}
</pre>
</div>
</p>
<p>
Comme dans l'exemple de base, le serveur instancie un objet <tt>ComputeImpl</tt> et l'enregistre dans le registry sous l'identifiant <tt>Compute</tt>.
</p>

</div>

<!-- __________ Securite  ________________________ -->
<div class="slide">
<h1>Gestionnaire SÃ©curitÃ©</h1>

<p>
L'une des principales difficultÃ©s de RMI est la gestion de la sÃ©curitÃ©.
<ul>
	  <li>Il est nÃ©cessaire de modifier la politique trÃ¨s restrictive de sÃ©curitÃ© par dÃ©faut (<tt>$JAVA_HOME/lib/security/java.policy</tt>). 
	  La mÃ©thode prÃ©conisÃ©e est d'associer un fichier dÃ©crivant la politique avec la JVM lancÃ©e 
	  (<tt>-Djava.security.policy=fichier</tt>)
	  (<a href="http://java.sun.com/j2se/1.4.2/docs/guide/security/PolicyFiles.html">syntaxe</a>).
	  </li>

	  <li>Un programme n'a pas de gestionnaire de sÃ©curitÃ© par dÃ©faut, et empÃªche certaines opÃ©rations (comme le tÃ©lÃ©chargement de code). On peut en crÃ©er un:
	  <ul>
		    <li>par programme (<tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/SecurityManager.html">SecurityManager</a></tt>),</li>
		    <li>par fichier <tt>-Djava.security.manager</tt>.</li>
	  </ul>
	  </li>
</p>

</div>

<!-- __________ Codebase  ________________________ -->
<div class="slide">
<h1>Code base</h1>

<p>
<ol>
<li>Quand un client invoque une mÃ©thode d'un objet distant, le <b>rmiregistry</b> (lui aussi distant) retourne une rÃ©fÃ©rence Ã  cet objet (stub). Le rmiregistry doit pouvoir accÃ©der aux classes correspondant Ã  ce stub.  </li>
<li>
Le  rmiregistry cherche d'abord dans son CLASSPATH la dÃ©finition de la classe.
</li>
<li>  
Ensuite, la recherche se fait dans <tt>codebase</tt>, spÃ©cifiÃ© au lancement du serveur
(qui enregistre l'objet). <br/>
<code>
-Djava.rmi.server.codebase=
 http://icps.u-strasbg.fr/~genaud/codebase/
</code>
</li>
<li>
Le client pourra alors tÃ©lÃ©charger la dÃ©finition des classes de la codebase.
</li>
</ol>
</p>

</div>
<div class="handout">

Remarque: en utilisant une codebase, le serveur doit pouvoir accÃ©der avec son CLASSPATH aux definitions de classes, mais le rmiregistry ne doit pas pouvoir le faire.

</div>

<!-- ______________________ Deploiement ______________________ -->
<div class="slide">
<h1>Compilation : fichiers</h1>
<table class="list">
<tr><th class="list">client</th><th class="list">  serveur</th></tr>
<tr><td colspan="2">Sources</td></tr>
<tr class="list"><td>Client.java       </td><td>  Server.java</td></tr>
<tr class="list"><td>Task.java         </td><td>  Task.java</td></tr>
<tr class="list"><td>TaskPi.java        </td><td> 
<tr class="list"><td>Operation.java     </td><td> Operation.java</td></tr>
<tr class="list"><td>                   </td><td> OperationImpl.java</td></tr>
<tr><td colspan="2"><tt>javac *.java</td></tr>
<tr class="list"><td>TaskPi.class       </td><td> </td></tr>
<tr class="list"><td>                   </td><td>  OperationImpl.class</td></tr>
<tr class="list"><td>                   </td><td>  OperationImpl_Skel.class</td></tr>
</table>
</div>


<!-- ______________________ Exercice ______________________ -->
<div class="slide">
<h1>Exercice</h1>

Ecivez un systÃ¨me de <i>polling</i> de messages, avec plusieurs clients,
un serveur:
<ul>
	<li>un client envoie un message vers un serveur connu,</li>
	<li>le serveur enregistre le message du client,</li>
	<li>et lui renvoie tous les messages non encore lus provenant d'autres clients.</li>
</ul>

</div>
<!-- ____________________ FIN ___________________________ -->
</body>
</html>
